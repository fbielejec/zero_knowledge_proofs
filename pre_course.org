* IN-PROGRESS Pre-Course
- https://leather-bulb-be5.notion.site/ZKP-Pre-Course-Self-Learn-Material-V2-31b9618231cd424fa72bdc5f11221bea
* DONE Linear algebra
** DONE vectors: https://www.youtube.com/watch?v=fNk_zzaMoSs

---

*NOTE: summary*

- geometric interpretation of vector addition and scalar multiplication

---


#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

  # Define vectors
  a = np.array([3, -5])
  b = np.array([2,1])

  # Add vectors
  result = a + b  # Element-wise addition
  print(f"{a}+{b}={result}")

  # multiply vector by a scalar
  scalar = 2
  print(f"{scalar}*{result}={scalar*result}")
#+END_SRC

#+RESULTS:
: [ 3 -5]+[2 1]=[ 5 -4]
: 2*[ 5 -4]=[10 -8]

** DONE Linear combinations, span, and basis vectors https://www.youtube.com/watch?v=k7RM-ot2NWY

---

*NOTE: summary*

- coordinates: two dimensional vectors
- coordinates can be thought of as pairs of scalars that scale $\hat{i}$ and $\hat{j}$ (the *basis* of the coordinate system).
- in xy coordinate system $\hat{i}$ is a special vector that points to the right with a length of 1 (unit vector in the x direction)
- $\hat{j}$ is a special vector that points up with a length 1 (unit vector in the y direction)
- x coordinates scales $\hat{i}$ and y coordinates scales $\hat{j}$.
- the vector that these coordinates describe is then the sum of the two scaled vectors $\hat{i}$ and $\hat{j}$:
  - e.g. $[3,-2] = (3) \cdot \hat{i} + (-2)\cdot \hat{j}$
- you can in fact arbitrarily choose any two different vectors as the basis and you get an entirely different coordinate system
- any time you scale and add two vectors like this it's called a *linear combination* of those two vectors:

=Definition: linear combination of vectors=

$a \cdot \vec{v} + b\cdot \vec{w}$

where:
- $a,b$ are scalars

=Definition: linearly dependent vectors=

One of the vectors can be expresses as a linear combination of the others:

$\vec{u} = a \cdot \vec{v} + b\cdot \vec{w}$

where:
- $a,b$ are some scalars (fixed values)

=Definition: linearly independent vectors=

One of the vectors cannot be expresses as a linear combination of the other(s):

$\forall a\in \mathbb{R} \hspace{1em} \vec{v} \neq a \cdot \vec{v}$
where:
 - the example is for 2 vectors but the same definition holds for 3 (or more) vectors.

- the *span* of two vectors is the set of all possible linear combinations of those vectors.
- 1 vector can describe all of 1d space (multiplied by a scalar can eventually span the whole space)
- adding a linearly independent vector to that one one unlocks another dimension
  - adding a linearly dependent one adds nothing new (no new dimension)
---

=Example: basis of the coordinate system=

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np
  import random

#  np.random.seed(2137)

  # Define basis vectors
  i_hat = np.array([1,0])
  j_hat = np.array([0,1])

  v = np.array([3,-2])

  print(f"{v} = {v[0] * i_hat + v[1] * j_hat}")
#+END_SRC

#+RESULTS:
: [ 3 -2] = [ 3 -2]

=Example: span is a set of all linear combinations of a vector=

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np
  import random

  np.random.seed(2137)

def span(i, j):
    combinations = set()
    while len(combinations) < 10:
        a = random.randint(-10,10)
        b = random.randint(-10,10)
        combination = a*i + b *j
        combinations.add(tuple(combination))
    return combinations

# these two vectors are linearly dependent (they are a linear combination of one another)
i = np.array([1,0])
j = 2 * i
# notice how only one coordinate varies (only 1 dimension)
print(f"span of i={i} and j={j}: {span(i,j)}")

# these two vectors are linearly independent
i = np.array([1,0])
j = np.array([0,1])
# notice how both coordinates vary (we gain 1 dimension)
print(f"span of i={i} and j={j}: {span(i,j)}")
#+END_SRC

#+RESULTS:
: span of i=[1 0] and j=[2 0]: {(-8, 0), (4, 0), (-12, 0), (-17, 0), (-27, 0), (7, 0), (13, 0), (10, 0), (6, 0), (1, 0)}
: span of i=[1 0] and j=[0 1]: {(-9, -9), (4, 1), (2, -3), (1, 1), (3, 10), (-6, -3), (2, 9), (1, -3), (-8, -2), (-10, 8)}

** DONE Linear transformations and matrices: https://www.youtube.com/watch?v=kYB8IZa5AuE

---

*NOTE: chapter summary*

- transformations are functions with vectors as inputs that return vectors as outputs
- they act on the entire vector space
- linear transformations mean:
  - all lines must remain lines, without getting curved
  - origin of the coordinate system must remain in place
- the above property means that you need to only concern yourself with tracking the transformation of the origin, since every other vector fals in place (you can deuce where it lands based on where $\hat{i}$ and $\hat{j}$ land.
- 2D linear transformations is completely described by just four numbers, the two coords for where $\hat{i}$ lands and two coords where $\hat{j}$ lands.
- think of it this way: after applying certain transformation that morph the space in a linear way the vector $vec{v}$ lands on $vec{v_{transformed}}$ in this new space
  - but it can still be described in terms of the (now transformed) basis vectors

- *Formal linearity properties*
  - $L(\vec{v} + \vec{w})= L(\vec{v}) + L(\vec{w})$
  - $L(c\vec{v})= cL(\vec{v})$

---

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np
#  import random

  # basis vectors
  i_hat = np.array([1,0])
  j_hat = np.array([0,1])

  v = -1*i_hat + 2*j_hat

  # applying some transformation:
  transformed_i = np.array([1,-2])
  transformed_j = np.array([3,0])

  transformed_v = -1* transformed_i + 2*transformed_j

  # matrix for the linear transformation:
  m = np.array([
                [transformed_i[0],transformed_j[0]],
                [transformed_i[1],transformed_j[1]]
               ])
  v = np.array([-1,2])

  # matrix times vector gives us the same transformed vector
  print(f"{transformed_v} == {m} * {v} == {np.matmul(m, v)}")
#+END_SRC

#+RESULTS:
: [5 2] == [[ 1  3]
:  [-2  0]] * [-1  2] == [5 2]

** DONE Matrix multiplication as composition https://www.youtube.com/watch?v=XkY2DOUCWMU

---

*NOTE: chapter summary*

- linear transformations can be combined (composed)
 - e.g. a rotation and a shear
- this combination is matrix multiplication
  - e.g. $A(BC) = (AB)C $
- matrix mulitplication is NOT commutative $A*B \neq B*A$

---

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np
  import random

  v = np.array([-1, 2])

  # counter-clockwise rotation by 90 deg
  # i_hat => [0,1]
  # j_hat => [-1,0]
  m1 = np.array([
                [0, -1],
                [1, 0]
               ])

  # a shear
  # i_hat => [1,0]
  # j_hat => [1,1]
  m2 = np.array([
                [1, 1],
                [0, 1]
               ])

  # composed tranformation has the same effect as applying two successive ones
  # reading m2 * m1 is right to left (first rotation than shear)
  print(f"{np.matmul(np.matmul(m2, m1),v)} == {np.matmul(m2, np.matmul(m1, v)) }")
#+END_SRC

#+RESULTS:
: [-3 -1] == [-3 -1]

** DONE 3D linear transformations: https://www.youtube.com/watch?v=rHLEWRxRGiM

---

*NOTE: chapter summary*

- basis vectors are now : $\hat{i}, \hat{j}, \hat{k}$
- applying a transformation is again done by multiplying the vectors of the space by the transformation matroiix, which consist of the transformed base vectors $\hat{i}, \hat{j}, \hat{k}$
  - m * v = v[0] * m[,0] +  v[1] * m[,1] +  v[2] * m[,2]

---

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np
  import random

  # basis
  i = np.array([1,0,-1])x
  j = np.array([1,1,0])
  k = np.array([1,0,1])

  m = np.array([
                [i[0], j[0], k[0]],
                [i[1], j[1], k[1]],
                [i[2], j[2], k[2]]
               ])

  v = np.array([3,2,1])



  print(f"{m}")
#+END_SRC

#+RESULTS:
: [[ 1  1  1]
:  [ 0  1  0]
:  [-1  0  1]]

** DONE The determinant: https://www.youtube.com/watch?v=Ip3X9LOh2dk

---

*NOTE: chapter summary*

- Linear transformations stretch or squish the space
- The determinant measures how much volumes change during a transformation (increase or decrease)
  - e.g. in a case of a linear transformation $3*\hat{i}$ and $2*\hat{i}$ a square on the space grid that was 1:1 is now 2:3
  - if the area was A it is now 6*A
- det(M) where M is the transformation matrix is the measure of that increase (or decrease in the area)
- It is also possible that the area after applying a transformation does not change at all.
  - In that case $det(M)=1$
- It is even possible for a transformation to squish the entire space into a single line, or a point ($det(M)=0$).
- Negative determinant means that the transformation inverts the space
 - it's absolute value will still tell you the factor of the area increase (or decrease)
- In case of 3 dimensions we can talk about the volume increasing or decreasing
- computing the determinant:
$det(\begin{bmatrix}
a & b \\
c & d
\end{bmatrix})=ad-bc$

- $det(M_1 \cdot M_2) = det(M_1) \cdot det(M_2)$

---

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np
  import random

  # transformed basis vectors
  i_hat = 3 * np.array([1,0]) # i scaled by factor of 3
  j_hat = 2 * np.array([0,1]) # j scaled by factor of 2

  # transformation matrix
  m = np.array([
                [i_hat[0],j_hat[0]],
                [i_hat[1],j_hat[1]]
               ])

  print(f"det({m}) = {np.linalg.det(m)}")
#+END_SRC

#+RESULTS:
: det([[3 0]
:  [0 2]]) = 6.0

** DONE Inverse matrices, column space, rank and null space: https://www.youtube.com/watch?v=uQhTuRlWMxw

---

*NOTE: chapter summary*

- solving linear systems of equations
- keywords:
  - Gaussian elimination
  - raw echelon form

- Example: a linear system of equations:

$\begin{cases}
2x + 5y +3z=-3 \\
4x+0y+8z = 0 \\
1x + 3y + 0z = 2
\end{cases}$

- Same system in a matrix form:

$\begin{bmatrix}
2 & 5 & 3 \\
4 & 0 & 8 \\
1 & 3 & 0
\end{bmatrix} \cdot \begin{bmatrix} x\\ y\\ z \end{bmatrix} = \begin{bmatrix} -3\\ 0\\ 2 \end{bmatrix}$

- A $\cdot \vec{x} = \vec{v}$
- where:
  - $A$ corresponds to some linear transformation, therefore the equations means looking for a vector $\vec{x}$ which after applying $A$ lands on $\vec{v}$

- *Determinant*
- We can check the determinant to conclude whether the system has a solution:
- Case 1: $det(A) \neq 0$
  - this means the transformation preserves all the dimensions and there is a unique solution.
  - In this case solving for $\vec{x}$ is akin to reversing the linear transformation applied by $A$:
  - $x= A^{-1} \times \vec{v}$
  - where $A^{-1}$ (inverse of $A$) is basically a different linear transformation (a transformation which reverses transformation $A$).
  - Applying $A$ and then inversing it: $A\cdot A^{-1}=I$ gets us right back to where we started (a transformation that does nothing, an identity matrix).
- Case 2: $det(A) = 0$
  - the transformation squishes the space into a smaller dimension, there is no inverse
  - there can still be a solution (if the vector $\vec{v}$ "lives" on the line that the space is squished to)

- *Rank: number of dimensions in the transformed space*
  - when the output of the transformation is a line (it's one dimensional) we say that transformation $A$ has a rank of 1.
  - if all the vectors land on a plane it has a rank of 2.

- *Column space*
 - the set of all possible outputs $A\vec{v}$
 - matrix is full rank if the rank is as high as it can be (i.e. equals the number of columns of that matrix)

- *Null space (matrix kernel)*
  - what the set of all the solutions looks like

---

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

  # counter-clockwise rotation
  a = np.array([[0,1],
                [-1,0]])

  # clockwise rotation
  a_inv = np.linalg.inv(a)

  print(f"{a}^-1 = {a_inv}")

  # this is the identity matrix, it leaves i_hat and j_hat where they started
  print(f"a^-1 a = {np.matmul(a, a_inv)}")

#+END_SRC

#+RESULTS:
: [[ 0  1]
:  [-1  0]]^-1 = [[-0. -1.]
:  [ 1.  0.]]
: a^-1 a = [[1. 0.]
:  [0. 1.]]

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np
  #from sympy import symbols, solve, Eq, lambdify

  a = np.array([[2,2],
                [1,3]])

  #x = np.array([symbols('x'),symbols('y')])

  v = np.array([-4,-1])

  # positive determinant
  print(f"det({a}) = {np.linalg.det(a)}")

  # x = A^{-1} * v
  a_inv = np.linalg.inv(a)
  x = np.matmul(a_inv,v)
  print(f"x = {x}")

#+END_SRC

#+RESULTS:
: det([[2 2]
:  [1 3]]) = 4.0
: x = [-2.5  0.5]

** DONE Nonsquare matrices as transformations between dimensions: https://www.youtube.com/watch?v=v8VSDg_WQlA

---

*NOTE: chapter summary*

- transformations between dimension such as ones that take 2D vectors to 3D vectors
 - such transformations are still linear (origin maps to the origin and the gridlines remain parallel and evenly spaced)
- a transformation that takes a 2D space to a 1D (a line) is also perfectly possible
  - e.g. $\begin{bmatrix} 2 & 1 \end{bmatrix}$ means that $\hat{i}$ lands on 2 and $\hat{j}$ lands on 1

---

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

  # output of a transformation that takes i to:
  transformed_i = np.array([2,-1,-2])
  # and j to:
  transformed_j = np.array([0,1,1])

  # 3 x 2 matrix
  a = np.array([[transformed_i[0], transformed_j[0]],
                [transformed_i[1], transformed_j[1]],
                [transformed_i[2], transformed_j[2]]])

#+END_SRC

#+RESULTS:

** DONE Dot products and duality: https://www.youtube.com/watch?v=LyGKycYT2v0

---

*NOTE: chapter summary*

- matrix-vector product <=> dot product

---

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

  # original vector in 2D space
  v = np.array([[4], [3]])

  # a transformation that takes 2D to 1D (i to 1, j to -2)
  a = np.array([1, -2])

  v_transformed = np.matmul(a, v)
  print(f"L({v}) = {v_transformed}")
#+END_SRC

#+RESULTS:
: L([[4]
:  [3]]) = [-2]

* DONE Practice Problems
** DONE Exercise 1

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

  A = [[1,2,3],[4,5,6],[7,8,9]]
  B = [[1,1,1],[2,2,2],[3,3,3]]
  C = [[2,3,4],[6,7,8],[10,11,12]]

  def add_arrays(A, B):
      return np.array(A) + np.array(B)

  assert (add_arrays(A, B) == np.array(C)).all()

  # .all = element-wise equlity check (every element in the array is true)
  print(np.array([True, True, True]).all())
  print(np.array([False, True, True]).all())
#+END_SRC

#+RESULTS:
: True
: False

** DONE Exercise 2: matrix multiplication

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

  def matrix_multiply(A, B):
      return np.matmul(A, B)

  A = np.array([[0,1],
                [-1,0]])

  B = np.array([[-0., -1.],
                [ 1.,  0.]])

  C = np.array([[1., 0.],
                [0., 1.]])

  assert (matrix_multiply(A, B) == C).all()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

  def element_wise_multiply(A, B):
      return np.multiply(A,B)

  A  = np.array([[0,1],
                 [-1,0]])

  B = np.array([[-0., -1.],
                [ 1.,  0.]])

  C = np.array([[0., -1.],
                [-1, 0.]])

  assert (element_wise_multiply(A, B) == C).all()
#+END_SRC

#+RESULTS:

** DONE Exercise 3: dot product

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

  def dot_product(A, B):
      return A @ B

  A = np.array([1,2,3,4])
  B = np.array([[1],[2],[3],[4]])

  assert (dot_product(A, B) == 30)
#+END_SRC

#+RESULTS:

** DONE Exercise 4: linear combinations

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

  def linearCombination(A, B, a, b):
      # Todo, add your code
      return a*A + b*B

  vector1 = np.array([1,2])
  vector2 = np.array([5,6])
  scalar1 = 3
  scalar2 = 10

  assert (np.array([53, 66]) == linearCombination(vector1, vector2, scalar1, scalar2)).all()
#+END_SRC

#+RESULTS:

** DONE Exercise 5: modular arithmetic (computing a multiplicative inverse)

- The challenge here is to compute the modular inverse of 15 % 1223.
- That is 15 * x % 1223 == 1.

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

  a=15;m=1223;

  # multiplicative inverse exists (a and m are coprime)
  print(f"GCD({a},{m})={np.gcd(a,m)}")

  # GCD (48,18) by euclidean algorithm
  48 % 18
  18 % 12
  12 % 6 # gcd(48,18) = 6

  def gcd(a, b):
      if b == 0:
          return a
      return gcd(b, a % b)

  assert(gcd(a,m) == 1)

  a=48;b=18;

  def gcdExtended(a, b):
      # Base Case
      if a == 0 :
          return b,0,1

      gcd,x1,y1 = gcdExtended(b%a, a)

      # Update x and y using results of recursive the call
      x = y1 - (b//a) * x1
      y = x1

      return gcd,x,y

  # example15 moonmath
  assert(gcdExtended(6,5) == (1,1,-1))

  # 15 * x % 1223 == 1 <=>
  # 15 * x1 + 1223 * y1 == 1
  gcd,x1,y1 = gcdExtended(a,m)

  print(f"{a*x1 + m*y1} == {a} * {x1} + {m} * {y1} == {gcd}")
  print(f"{a}^-1 * {a} mod {m} = {(x1 * a) % m} => {a}^-1 mod {m} = {x1}")

  assert a * x1 % m == 1
#+END_SRC

#+RESULTS:
: GCD(15,1223)=1
: 1 == 48 * -586 + 1223 * 23 == 1
: 48^-1 * 48 mod 1223 = 1 => 48^-1 mod 1223 = -586

** DONE Exercise 6: Column and Row Slicing

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np

def get_column_as_1d(A, col_number):
    return A[:, col_number]

def get_row_as_1d(A, row_number):
    return A[row_number, :]

A = np.array([[1,2,3],[4,5,6],[7,8,9]])

# [2,5,8]
print(get_column_as_1d(A, 1))

print(get_row_as_1d(A, 2)) # [7,8,9]
#+END_SRC

#+RESULTS:
: [2 5 8]
: [7 8 9]

* DONE P vs NP Problem
- *P (Polynomial) Problems:* problems that can be solved in polynomial time and whose solutions can be verified in polynomial time are called *problems in P*.
  - e.g. Sorting a list : e.g. mergesort takes $\mathcal{O}(n \cdot log(n))< \mathcal{O}^{2}$ to sort a list and $\mathcal{O}(n)$ to verify that the list is sorted.
- *The Witness*: proof that you solved a problem correctly
  - in the example above a sorted list would be a witness
- *NP (non-deterministic polynomial) Problems:*
  - Any problem whose proposed solution (a *witness*) can be quickly verified as correct is a problem in NP.
  - However, finding the solution might require exponential resources.
  - Example: Computing the solution to a Sudoku puzzle and verifying the proposed solution to a Sudoku puzzle.
    - we can quickly verify the solution is correct simply by looping over the columns, rows, and subgrids, meaning the witness can be verified in polynomial time.
    - computing the solution requires significantly more resources: $\mathcal{O}(c^n)$, where $n$ is the number of rows == number of columns in the puzzle
  - Example: 3-coloring a map: https://www.youtube.com/watch?v=WlcXoz6tn4g
- *Problems in PSPACE*
  - Problems that require exponential resources to solve and verify
- *P vs NP*
  - P is the class of problems that can be solved and verified efficiently
  - NP is the class of problems that can be verified efficiently.
  - are these two classes of the problems the same?
  - Finding a solution is always *at least as hard as verifying it*. (By definition, solving a problem includes finding the correct answer, which means an algorithm that solves the problem is also verifying its answer in the process)
  - If P = NP, it would mean that whenever we can find an efficient method for verifying a solution, we can also find an efficient method for finding that solution.
  - researchers widely speculate that $P \neq NP$ and $NP \neq PSPACE$, no formal mathematical proof exists for these conclusions.
* DONE Expressing problems and solutions as Boolean formulas

- All problems in P and NP can be verified by transforming them to *boolean formulas*.

---

*NOTE: sage boolean logic cheatsheet*

- operators &, |, ~, ^ corresponding to and, or, not, xor
- also existing ->, <-> : if...then, if and only if.

#+BEGIN_SRC sage :session . :exports both
  import sage.logic.propcalc as propcalc

  f = propcalc.formula("(x1 | ~x2 | ~x3) & (~x2 | x3 | x4) & (~x2 | ~x3 | ~x4)")
  f.evaluate({'x1' : True, 'x2' : False, 'x3' : True, 'x4' : False})
#+END_SRC

#+RESULTS:
: True

---

- For example
  - $A > B$ can be modeled with $A \land \neg B$
  - $A = B$ can be modeled with $(A \land B) \lor \neg (A \lor B)$

- Checking whether A > B (in 4 bit logic)

#+BEGIN_SRC jupyter-python :session zk :async yes
  A=11
  B=9

  def bits(n, endian='little'):
      bits_le = [(n >> i) & 1 for i in range(4)]
      if endian == 'big':
          return bits_le[::-1]
      return bits_le

  bits_be_11 = bits(A, endian = 'big')
  print(f"11 = {bits_be_11}")

  bits_be_9 = bits(B, endian = 'big')
  print(f"9 = {bits_be_9}")

  # Binary comparison by most significant different bit
  def compare(bits_p, bits_q):
      """
      Compare integers P and Q bit decomposition
      Assumes same number of bits!

      Returns:
        0 if P == Q, 1 id P > Q, -1 if P < Q
      """
      for idx in range(len(bits_p)):
          p = bits_p[idx]
          q = bits_q[idx]
          if p != q:
              return p - q
      return 0

  compare(bits_be_11, bits_be_9)
#+END_SRC

#+RESULTS:
:RESULTS:
: 11 = [1, 0, 1, 1]
: 9 = [1, 0, 0, 1]
: 1
:END:

- checking if $P \geq  Q$ using a boolean formula:
  - bits in P are $[p_{4}, p_{3}, p_{2}, p_{1}]$ (ordered MSB to LSB)
  - bits in Q are $[q_{4}, q_{3}, q_{2}, q_{1}]$

$\begin{cases}
 (p_{4} > q_{4}) \hspace{.5em}  \lor \\
((p_{4} = q_{4}) \land (p_{3} > q_{3})) \hspace{.5em} \lor \\
((p_{4} = q_{4}) \land (p_{3} = q_{3}) \land (p_{2} > q_{2}) ) \hspace{.5em} \lor \\
((p_{4} = q_{4}) \land (p_{3} = q_{3}) \land (p_{2} = q_{2}) \land ((p_{1} > q_{1}) \lor (p_{1} = q_{1}) ) )
\end{cases}$

#+BEGIN_SRC sage :session . :exports both
  import sage.logic.propcalc as propcalc

  # bit p > q
  def p_geq_q(bit_p, bit_q):
      return propcalc.formula("p{bit_p} & ~q{bit_q}".format(bit_p = bit_p, bit_q = bit_q))

  # bit p == q
  def p_eq_q(bit_p, bit_q):
      return propcalc.formula("(p{bit_p} & q{bit_q}) | ~(p{bit_p} | q{bit_q})".format(bit_p = bit_p, bit_q = bit_q))

  witness = {'p4' : True, 'p3' : False, 'p2' : True, 'p1' : True,
             'q4' : True, 'q3' : False, 'q2' : False, 'q1' : True}

  # I know a witness (decomposed P and Q) such that P >= Q
  p_geq_q(4,4).evaluate(witness) | (p_eq_q(4,4).evaluate(witness) & p_geq_q(3,3).evaluate(witness)) | (p_eq_q(4,4).evaluate(witness) & p_eq_q(3,3).evaluate(witness) & p_geq_q(2,2).evaluate(witness)) | (p_eq_q(4,4).evaluate(witness) & p_eq_q(3,3).evaluate(witness) & p_eq_q(2,2).evaluate(witness) & (p_geq_q(1,1).evaluate(witness) | p_eq_q(1,1).evaluate(witness)))

#+END_SRC

#+RESULTS:
: True

- You can *check if a list is sorted* using such an expression:
  - repeatedly apply the above comparison expression to each pair of adjacent elements in the list and combine the comparison expressions using the *AND* operation.

- In the ZK literature, we often refer to Boolean formulas as *Boolean circuits*.
  - Creating a zero knowledge proof for a problem boils down to translating the problem to a circuit
* DONE Finite fields: https://www.youtube.com/watch?app=desktop&v=ColSUxhpn6A
** DONE Ring

=Definition=

A *ring* $(R, +, \cdot)$ is a set $R$ equipped with two binary operations:
- *addition* $+$
- and *multiplication* $\cdot$.

Ring satisfies the following axioms:

1. *Abelian Group under Addition*:
   - *Closure*: $\forall a, b \in R, \ a + b \in R$.
   - *Associativity*: $\forall a, b, c \in R, \ (a + b) + c = a + (b + c)$.
   - *Identity (Additive Zero)*: $\exists 0 \in R \text{ s.t. } a + 0 = a$.
   - *Inverses (Additive Inverses)*: $\forall a \in R, \exists (-a) \in R \text{ s.t. } a + (-a) = 0$.
   - *Commutativity*: $\forall a, b \in R, \ a + b = b + a$.

2. *Monoid under Multiplication*:
   - *Closure*: $\forall a, b \in R, \ a \cdot b \in R$.
   - *Associativity*: $\forall a, b, c \in R, \ (a \cdot b) \cdot c = a \cdot (b \cdot c)$.
   - *Identity (Multiplicative One, if it exists)*: Some rings have a multiplicative identity $1 \in R$ (called a *unital ring*).

3. *Distributivity*:
   - Left-distributivity: $a \cdot (b + c) = a \cdot b + a \cdot c$.
   - Right-distributivity: $(a + b) \cdot c = a \cdot c + b \cdot c$.

*Example: Ring of Integers $\mathbb{Z}$*

- *Addition*: Standard integer addition.
- *Multiplication*: Standard integer multiplication.
- *Properties*:
  - It is *commutative* $a \cdot b = b \cdot a$.
  - It has a *multiplicative identity* $1$.
  - But *not every element has a multiplicative inverse* (e.g., $2$ has no inverse in $\mathbb{Z}$).

** DONE Field
- Field is a set on which addition, subtraction, multiplication, and division are defined and behave as the corresponding operations on rational and real numbers.
- Formally a *field* $(F, +, \cdot)$ is a set $F$ with two operations (addition $+$ and multiplication $\cdot$) satisfying:
  - *Additive Abelian Group*:
    1) *Closure*: $\forall a,b \in F \hspace{.5em} (a + b) \in F$
    2) *Associativity*:$\forall a,b,c \in F \hspace{.5em} (a + b) + c = a + (b + c)$
    3) *Identity*: $\exists 0 \in F \text{ s.t. } a + 0 = a$
    4) *Inverse*: $\forall a \in F \hspace{.5em} \exists (-a) \in F \text{ s.t. } a + (-a) = 0$
    5) *Commutativity*: $\forall a,b \in F \hspace{.5em} a + b = b + a$
  - *Multiplicative Abelian Group* (excluding 0):
    1) *Closure*: $\forall a,b \in F \hspace{.5em} a \cdot b \in F$
    2) *Associativity*: $(a \cdot b) \cdot c = a \cdot (b \cdot c)$
    3) *Identity*: $\exists 1 \in F \hspace{.5em} \text{ s.t. } a \cdot 1 = a$
    4) *Inverse*: $\forall a \ne 0, \exists a^{-1} \in F \text{ s.t. } a \cdot a^{-1} = 1$
    5) *Commutativity*: $a \cdot b = b \cdot a$
  - *Distributivity*:
    - $a \cdot (b + c) = a \cdot b + a \cdot c$
  - *No Zero Divisors*:
    - If $a \cdot b = 0$, then $a = 0$ or $b = 0$.

** DONE Difference Between a Ring and a Field

A *field* is a *special case of a ring* with stricter requirements:

| *Property*                 | *Ring* $R$                                                 | *Field* $F$                                                             |
|----------------------------+------------------------------------------------------------+-------------------------------------------------------------------------|
| *Additive Structure*       | Abelian group                                              | Abelian group                                                           |
| *Multiplicative Structure* | Monoid (not necessarily a group)                           | *Abelian group* (excluding zero)                                        |
| *Multiplicative Inverses*  | Not required (only for units)                              | *Every nonzero element has an inverse*                                  |
| *Zero Divisors*            | Allowed (e.g., $2 \cdot 3 = 0$ in $\mathbb{Z}/6\mathbb{Z}$ | *Never allowed* $a \cdot b = 0 \implies a = 0 \text{ or } b = 0$        |
| *Examples*                 | $\mathbb{Z}$, $\mathbb{Z}[x]$, $n \times n$ matrices       | $\mathbb{Q}$, $\mathbb{R}$, $\mathbb{C}$, $\mathbb{F}_p$ (finite field) |

*Key Distinctions*:
1. *Inverses*:
   - In a *ring*, only some elements (called *units*) have multiplicative inverses (e.g., in $\mathbb{Z}$, only $1$ and $-1$ are units).
   - In a *field*, *every nonzero element* has an inverse (e.g., in $\mathbb{Q}$, $2^{-1} = \frac{1}{2}$).

2. *Division*:
   - Fields allow division (except by zero).
   - Rings *do not* guarantee division (e.g., $3x = 2$ has no solution in $\mathbb{Z}$).

3. *Zero Divisors*:
   - Rings can have *zero divisors* (nonzero $a, b$ where $a \cdot b = 0$).
   - Fields *cannot* have zero divisors (since every nonzero element is invertible).

*Example of a Non-Field Ring: $\mathbb{Z}/6\mathbb{Z}$*
- Elements: $\{0, 1, 2, 3, 4, 5\}$ (integers mod 6).
- *Zero divisors*: $2 \cdot 3 = 0$ (but $2, 3 \neq 0$).
- *Not a field*: $2$ has no inverse (since $\nexists x$ such that $2x \equiv 1 \mod 6$).

*Example of a Field: $\mathbb{F}_5 = \mathbb{Z}/5\mathbb{Z}$*
- Elements: $\{0, 1, 2, 3, 4\}$ (integers mod 5).
- *Every nonzero element has an inverse*:
  - $2^{-1} = 3$ (since $2 \cdot 3 = 6 \equiv 1 \mod 5$).
  - $4^{-1} = 4$ (since $4 \cdot 4 = 16 \equiv 1 \mod 5$).

** IN-PROGRESS Finite field (Galois Field)

A *finite field* $\mathbb{F}_q$ (where $q = p^n$ for prime $p$ and $n \geq 1$) has:

1. *Cardinality*: Exactly $q$ elements.
2. *Prime Subfield*: $\mathbb{F}_p$ (the field of integers mod $p$).
3. *Characteristic*: $p$ (smallest integer s.t. $p \cdot 1 = 0$).
4. *Multiplicative Group*: The non-zero elements $\mathbb{F}_q^*$ form a *cyclic group* under multiplication.
   - There exists a *primitive element* (generator) $g$ such that every non-zero element is a power of $g$.
5. *Existence and Uniqueness*:
   - For every $q = p^n$, there exists *exactly one* finite field up to isomorphism.
6. *Frobenius Automorphism*:
   - The map $x \mapsto x^p$ is a field automorphism.

7. *Key Theorems*
   - *Fermat’s Little Theorem* (for $\mathbb{F}_p$):

$\forall a \ne 0 \in \mathbb{F}_p, \ a^{p-1} \equiv 1 \mod p$

   - *Lagrange’s Theorem*:
     - The order of any subgroup divides $q-1$.
   - *Primitive Element Theorem*:
     - $\mathbb{F}_q^*$ is cyclic of order $q-1$.

** TODO Exercises: Finite fields
- inverse for Z_100: https://youtu.be/ColSUxhpn6A?t=1520
- proof that Z_p is a finite field if p is prime (that groups of prime order are fields): https://youtu.be/ColSUxhpn6A?t=1606
 - Exercise 2.6 from Stanford notes
 - euler / fermat
 - extended_gcd
* DONE Elementary set theory: https://www.rareskills.io/post/set-theory
** IN-PROGRESS Set

=Definition: Set=

A *set* is a /well-defined collection/ of distinct objects, called *elements* (or *members*), where:
1) *Unordered*: The arrangement of elements does not matter (e.g., $\{1, 2\} = \{2, 1\}$.
2) *Distinctness*: No duplicates are allowed (e.g., $\{1, 1, 2\} = \{1, 2\}$).
3) *Well-defined membership*: For any object $x$ and set $A$, it must be clear whether $x \in A$ (belongs to $A$) or $x \notin A$ (does not belong).

=Key Properties=

- *Cardinality*:
- The number of elements in a set $A$ is denoted $|A|$.
- Example: $|\{a, b, c\}| = 3$.
- There are different levels of infinity in set theory.
  - For example there are infinitely many more real numbers than there are integers.
  - We say integers are *countably infinite* because you can literally count them out.
  - But there is no way to start counting real numbers which are *uncountably infinite*.

- *Subset*:

=Strict/Proper Subset=

- A set $A$ is a strict (or proper) subset of a set $B$, denoted $\subset$ or $\subsetneq$ if:
  1. *Every element of $A$ is in $B$* (i.e., $A \subseteq B$),
  2. *But $B$ contains at least one element not in $A$* (i.e., $A \neq B$).
- Example: $\{1, 2\} \subsetneq \{1, 2, 3\}$.

=Non-Strict Subset=

- A set $A$ is a /subset/ (not necessarily proper) of $B$, denoted $A \subseteq B$, if every element of $A$ is in $B$.
- This includes the case where $A = B$.


- *Equality*:
- Two sets $A$ and $B$ are equal ($(A = B$) if they contain the same elements.
- If $A$ is a subset of $B$ and $B$ is a subset of $A$, then $A=B$.
  - $A=B \Leftrightarrow A \subseteq B \text{ and } B \subseteq A$
- Example: $\{x \mid x^2 = 1\} = \{-1, 1\}$.

- *Empty Set*:
  The unique set with no elements, denoted $\emptyset$ or $\{\}$.

- *Ordered pair*
- Sets do not have an inherent order
- We can introduce *ordered pairs* as a new data structure emerge from sets of sets:
  - For example $(a,b)$ is an ordered pair created by the set $\{a, \{ b\} \}$.
  - $(a,b) \neq (b,a)$ because $\{a, \{ b\} \} \neq \{ \{ b\}, a \}$.

- *Operations*:
  - *Union*: $A \cup B = \{x \mid x \in A \text{ or } x \in B\}$.
  - *Intersection*: $A \cap B = \{x \mid x \in A \text{ and } x \in B\}$.
  - *Complement*: $A^c = \{x \mid x \notin A\}$ (relative to a universal set).
  - *Cartesian Product*: $A \times B = \{(a, b) \mid a \in A, b \in B\}$.
    - *NOTE*: cartesian products are not commutative in a general case.

** DONE Functions as subsets of cartesian products

- In the set-theoretic terms *function* is a subset of the Cartesian product of the *domain set* and *codomain set*.
  - i.e. function is a mapping from one set to another set.
- To define a function, we need the set we start from and the set we end at.
- We take the Cartesian product of these two sets, which results in every possible assignment from the input set to the output set.
- Then we take the subset of the Cartesian product to define the function as we like.
- When dealing with infinite sets like integers, we aren't bothered that we can't enumerate all the ordered points explicitly.

=Example=

Let $A = \{1,2,3\}$, $B = \{x, y, z\}$.
The cartesian product $A \times B= \{ (1,x), (1,y), (1,z), (2,x), \ldots (3,z)\}$.
The same represented in a tabular format:

|   | x       | y       | z       |
| 1 | (1,x)   | *(1,y)* | (1,z)   |
| 2 | (2,x)   | (2,y)   | *(2,z)* |
| 3 | *(3,x)* | (3,y)   | (3,z)   |

The highlighted subset of the product i.e. $\{ (1,y),(2,z),(3,x) \}$ defines a function:

$1 \rightarrow y$
$2 \rightarrow z$
$3 \rightarrow x$

=Example=

Let's define a mapping between non-negative real numbers (zero or greater) and non-negative integers (zero or greater) using the *floor function* (function that removes the decimal portion of a number):

$\mathbb{R} \time \mathbb{Z}$:

|       | 1          | 2            | ... | 499          | 500            |
|   1.5 | *(1.5, 1)* | (1.5, 2)     | ... | (1.5, 499)   | (1.5, 500)     |
| 2.772 | (2.772, 1) | *(2.772, 2)* | ... | (2.772, 499) | (2.772, 500)   |
|   ... | ...        | ...          | ... | ...          | ...            |
| 500.3 | (500.3, 1) | (500.3, 2)   | ... | (500.3, 499) | *(500.3, 500)* |

** DONE Set relations
- The action of taking the [[*Functions as subsets of cartesian products][subsets of cartesian products]] is called a *relation*
- A relation can be taken from a Cartesian product of a set with itself, or a set with another set.
- If we have two sets $A$ and $B$ (which may or may not be equal) and we take a subset of $A \times B$, then we say $a \in A$ is related to $b \in B$ if there is an ordered pair $(a,b)$ in the subset of $A \ times B$.

=Example=

$y = x^2$ as the subset of $\mathbb{Z} \times \mathbb{Z}$

| X\Y | 1       | 2     | 3     | 4       | ... |       9 |
|   1 | *(1,1)* | (1,2) | (1,3) | (1,4)   | ... |         |
|   2 | (2,1)   | (2,2) | (2,3) | *(2,4)* | ... |         |
|   3 | (3,1)   | (3,2) | (3,3) | (3,4)   | ... | *(3,9)* |
| ... |         |       |       |         |     |         |

- 2 from $X$ is related 4 from $Y$
- 3 from $X$ is not related to 4 from $Y$

** DONE Binary operator

=Definition: Binary Operator=

A *binary operator* on a set $A$ is a *function* that maps every ordered pair of elements from $A$ to another element in $A$:

$* : A \times A \to A$

where:
- $A \times A$ is the *Cartesian product* of $A$ with itself (the set of all ordered pairs $(a \in A, b \in A)$.
- The output $*(a, b)$  (typically written as $a * b$ must belong to $A$.

Binary operators must accept all members of set as its inputs (mapping is *surjective*).
Each pair from $A \times A$ must map to exactly one element of $A$ (the result of a binary operation must have one unambiguous answer, i.e. the mapping must be *injective*).

=Examples=

- *addition of integers*: take any two elements from the set of integers and add them together, you get another element from the set of integers (e.g. $(1,3) \mapsto 4$)
- *concatenation of strings* take any pair of strings from the set of strings, concatenate them, and the result is another string.

=Definition: Closure of a Binary Operator=

A binary operator $*$ on $A$ is *closed* (or $*A$ is closed under $*$) if applying $*$ to any two elements of $A$ *always* produces another element in $A$:

$\forall a, b \in A, \quad a * b \in A$

=Examples=

1. *Closed Operations*:
   - $+$ on $\mathbb{N}$: $\forall a, b \in \mathbb{N}, a + b \in \mathbb{N}$.
   - $\times$ on $\mathbb{Q}$: $\forall p/q, r/s \in \mathbb{Q}, (p/q) \times (r/s) \in \mathbb{Q}$.

2. *Not Closed*:
   - Subtraction ($-$) on $\mathbb{N}$: $3 - 5 = -2 \notin \mathbb{N}$.
   - Division ($/$) on $\mathbb{Z}$: $3 / 2 \notin \mathbb{Z}$.

=Constructing a binary operator=

- Start with a set $A$.
- Take a cartesian product $A \times A$ and call this set of ordered pairs $P$.
- Take a cartesian product $P \times A$
- Take a subset of that according to the operator definition

** IN-PROGRESS Exercises

*** Assume you have a proper definition for integers. Create a well-defined set of rational numbers.

$\mathbb{Q}=\{x=\frac{p}{q} \hspace{.5em} | \hspace{.5em} p,q \in \mathbb{Z}, q \neq 0 \}$

*** Define the subset relationship between integers, rational numbers, real numbers, and complex numbers.

- integers: $\mathbb{Z} = \{\dots, -2, -1, 0, 1, 2, \dots\}$
- rational numbers: $\mathbb{Q} = \left\{\frac{p}{q} \mid p, q \in \mathbb{Z}, q \neq 0\right\}$
  - proper superset of $\mathbb{Z}$: every integer is a rational number: $\forall z \in \mathbb{Z}: \hspace{.5em} z = \frac{z}{1}$
  - not every rational number is an integer, e.g. $\frac{1}{2}$ (and every other fractional for that matter).
- real numbers $\mathbb{R}$: All numbers on the continuous number line, including rational numbers $\mathbb{Q}$ and irrational numbers (e.g. $\pi$, $\sqrt{2}$, ...)
- complex numbers $\mathbb{C}$: numbers of the form $a + b \cdot i$, where $a, b \in \mathbb{R}$ and $i = \sqrt{-1}$.

Relationships:
 - $\mathbb{Z} \subseteq \mathbb{Q}$
 - $\mathbb{Q} \subseteq \mathbb{R}$
 - $\mathbb{R} \subseteq \mathbb{C}$

where:
 - $\subseteq$ denotes strict (proper) subset.

*** Define the relationship between the set of transcendental numbers and the set of complex numbers in terms of subsets. Is it a proper subset?

- *Transcendental numbers* are real or complex numbers that are /not/ roots of any non-zero polynomial equation with integer (or rational) coefficients.
- In other words, they are numbers that *cannot* be defined via algebraic equations.
- A number $x$ is transcendental if there is /no/ finite polynomial:

$P(x) = a_{n} \cdot x^{n} + a_{n-1} \cdot x^{n-1} + \dots + a_0$

where:
- $a_i \in \mathbb{Z}$ such that $P(x) = 0$.

- Almost all real numbers are transcendental (they vastly outnumber algebraic numbers, which are countable).
- All transcendental numbers are irrational, but not all irrationals are transcendental (e.g., $\sqrt{2}$ is irrational but algebraic).
- Transcendental numbers are /not/ closed under arithmetic operations. For example:
  - $\pi + (-\pi) = 0$ (algebraic).
  - $e \times e^{-1} = 1$ (algebraic).

Relationship is strict (proper):
- $\mathbb{T} \subsetneq \mathbb{C}$
- Every transcendental number is a complex number (since it can be represented as $t + 0\cdoti$ where $t \in \mathbb{T}$)
- But the sets are not equal, since e.g. $1 + i$ is complex but not transcendental.

*** Using the formal definition of equality, argue that if two finite sets have different cardinality, they cannot be equal.
+- Demonstrating this for infinite sets is a little trickier, so we skip that+
- Let' assume two finite sets $A=\{a_0, \ldots a_n \}$ and $B=\{ b_0, \ldots b_k \}$, where $n \neq k$, with different cardinalities: $|A| \neq |B|$
- if $A=B$ than they contain the same elements, meaning that $\forall x, \hspace{.5em} x \in A \iff x \in B$, contradicting $n \neq k$. QED

*** Compute the Cartesian product of $B \times A$
Let $A = \{1,2,3\}$, $B = \{x, y, z\}$

$A \times B$

|   | x     | y     | z     |
| 1 | (1,x) | (1,y) | (1,z) |
| 2 | (2,x) | (2,y) | (2,z) |
| 3 | (3,x) | (3,y) | (3,z) |

$B \times A$

|   | 1     | 2     | 3     |
| x | (x,1) | (x,2) | (x,3) |
| y | (y,1) | (y,2) | (y,3) |
| z | (z,1) | (z,2) | (z,3) |

$A \times B \neq $B \times A$

*** Define a mapping (function) from integers $\{ 1,2,3,4,5,6 \}$ to the set $\{ \text{even}, \text{odd} \}$

|   | even       | odd       |
| 1 | (1,even)   | *(1,odd)* |
| 2 | *(2,even)* | (2,odd)   |
| 3 | (3,even)   | *(3,odd)* |
| 4 | *(4,even)* | (4,odd)   |
| 5 | (5,even)   | *(5,odd)* |
| 6 | *(6,even)* | (6,odd)   |

$f(x) = \begin{cases}
\text{even} & \text{if }  x \mod 2 = 0 \\
\text{odd} & \text{else}
\end{cases}$

---

*NOTE*

This is the *parity function*, a canonical example of a surjective but non-injective function.

---

*** The Cartesian product of the polygons and the set of integers representing the number of sides

Let $polygons = \{triange, square, pentagon, hexagon, heptagon, octagon \}$ and a set of integers $\{0,1,2,3,4,5,6,7,8\}$.
Define a mapping such that the polygon maps to an integer representing the number of sides.

|          | 0 | 1 | 2 |            3 |          4 |            5 |           6 |            7 |           8 |
| triangle |   |   |   | (triangle,3) |            |              |             |              |             |
| square   |   |   |   |              | (square,4) |              |             |              |             |
| pentagon |   |   |   |              |            | (pentagon,5) |             |              |             |
| hexagon  |   |   |   |              |            |              | (hexagon,6) |              |             |
| heptagon |   |   |   |              |            |              |             | (heptagon,7) |             |
| octagon  |   |   |   |              |            |              |             |              | (octagon,8) |

*** Define a mapping between positive integers and positive rational numbers

*Solution 1 (using the Fundamental Theorem of Arithmetic)*

---

*NOTE: Fundamental Theorem of Arithmetic*

Every positive integer (i.e. every integer greater than 1) can be uniquely expressed as a product of prime numbers, up to permutation (i.e. up to the order of the factors) as:

$p_1^{k_1} \cdot p_2^{k_2} \cdots p_n^{k_n}$

where:
- $p_1,\ldots p_n$ are distinct prime numbers.
- $k_1,\ldots, k_n$ are positive integers that represent multiplicities of the primes.

---

By the [[file:~/CloudStation/Cryptography_101/zkSNARKs-notes/arithmetics.org::*Fundamental Theorem of Arithmetic][Fundamental Theorem of Arithmetic]], every integer can be represented as a product of primes.
Similarly every rational number, only that now $k_1,\ldots, k_n$ can be negative.

We take:

$k_j \mapsto \begin{cases} \frac{k_{j}+1}{2} & \text { if odd} \\ -\frac{k_{j}}{2} & \text { if even} \end{cases}$

Example:


$1=1^1 \mapsto 1^{\frac{1+1}{1}}=1$
$2=2^1 \mapsto 2^{\frac{1+1}{2}}=2$
$3=3^1 \mapsto 3^{\frac{1+1}{2}}=3$
$4=2^2 \mapsto 2^{-\frac{2}{2}}=\frac{1}{2}$
$5 \mapsto 5$
$6= 2^1 \cdot 3^1 \mapsto 2^{\frac{1+1}{2}} \cdot 3^{\frac{1+1}{2}}=6$
$7 \mapsto 7$
$8 = 2^3 \mapsto 2^{\frac{3+1}{2}}=4$

$\vdots$

More generally:

$p \mapsto p$
$p^2 \mapsto p^{-1}$
$p^3 \mapsto p^{2}$
$p^4 \mapsto p^{-2}$

$\vdots$

Such a mapping is a bijection:
- It's *injective (One-to-One)*: No two integers map to the same rational
- It's *surjective (Onto)*: Every positive rational appears in the list

*Solution 2*

1. Draw a table to construct rational numbers where the columns are the numerators and the rows are the denominators (a cartesian product of naturals with naturals)
2. Traverse the table grid diagonally (Cantor's Pairing):
   - First diagonal: $\frac{1}{1}$
   - Second diagonal: $\frac{2}{1}, \frac{1}{2}$
   - Third diagonal: $\frac{3}{1}, \frac{2}{2}, \frac{1}{3}$
   - ...
3. Skip the duplicates
   - Omit fractions where $\gcd(p, q) \neq 1$ (e.g., skip $\frac{2}{2}$ since it equals $\frac{1}{1}$).

| *q\p* | *1*     | *2*    | *3*    | *4*    | *5*     | *6* | *7* | *8* |
|-------+---------+--------+--------+--------+---------+-----+-----+-----|
| *1*   | 1: 1/1  | 2: 2/1 | 4: 3/1 | 6: 4/1 | 10: 5/1 | ... |     |     |
| *2*   | 3: 1/2  | +2/2+  | 7: 3/2 | +4/2+  | ...     |     |     |     |
| *3*   | 5: 1/3  | 8: 2/3 | +3/3+  | ...    |         |     |     |     |
| *4*   | 9: 1/4  | +2/4+  | ...    |        |         |     |     |     |
| *5*   | 11: 1/5 | ...    |        |        |         |     |     |     |
| *6*   | ...     |        |        |        |         |     |     |     |
| *7*   |         |        |        |        |         |     |     |     |
| *8*   |         |        |        |        |         |     |     |     |

Example:
$1 \mapsto 1$
$2 \mapsto 2$
$3 \mapsto \frac{1}{2}$
$4 \mapsto 3$
$5 \mapsto \frac{1}{3}$
$6 \mapsto 4$
$7 \mapsto \frac{3}{2}$
$8 \mapsto \frac{2}{3}$

*** Pick a subset of ordered pairs that defines (a \times b) (mod 3)

Let's use an example of a set $A=\{0,1,2\}$. Taking the Cartesian product $A \times A $

|   | 0     | 1     | 2     |
| 0 | (0,0) | (0,1) | (0,2) |
| 1 | (1,0) | (1,1) | (1,2) |
| 2 | (2,0) | (2,1) | (2,2) |

Then we take the Cartesian product of this new set of pairs with the original set

|       | 0           | 1           | 2           |
| (0,0) | *((0,0),0)* | ((0,0),1)   | ((0,0),2)   |
| (0,1) | *((0,1),0)* | ((0,1),1)   | ((0,2),2)   |
| (0,2) | *((0,2),0)* | ((0,2),1)   | ((0,2),2)   |
| (1,0) | *((1,0),0)* | ((1,0),1)   | ((1,0),2)   |
| (1,1) | ((1,1),0)   | *((1,1),1)* | ((1,1),2)   |
| (1,2) | ((1,2),0)   | ((1,2),1)   | *((1,2),2)* |
| (2,0) | *((2,0),0)* | ((2,0),1)   | ((2,0),2)   |
| (2,1) | ((2,1),0)   | ((2,1),1)   | *((2,1),2)* |
| (2,2) | ((2,2),0)   | *((2,2),1)* | ((2,2),2)   |

Subset which defines $a \times b \hspace{.5em} (\text{mod } 3)$ is in *bold*

*** TODO Define our set $A$ to be the numbers ${0,1,2,3,4}$ and our binary operator to be subtraction modulo 5. Define all the ordered pairs of $A \times A$ in a table, then map that set of ordered pairs to $A$.

* IN-PROGRESS Elementary Group Theory
- https://www.rareskills.io/post/group-theory
** IN-PROGRESS Cyclic groups

=Definition: cyclic group=

A group $(G, \cdot)$ is *cyclic* if there exists an element $g \in G$ (a *generator*) such that:

$G = \{ g^n \mid n \in \mathbb{Z} \}$

where:
- $g^0 = e $ (the identity element),
- $ g^n = g \cdot g \cdot \dots \cdot g $ ($n$ times) for $n > 0$,
- $ g^{-n} = (g^{-1})^n $ for $n > 0$.

If the group operation is addition ($+$), we write:

$G = \{ n \cdot g \mid n \in \mathbb{Z} \}$

where:
- $n \cdot g = g + g + \dots + g$ ($n$ times).

*Properties of Cyclic Groups*

- A cyclic group is a group that has an element such that every element in the group can be generated by applying the binary operator repeatedly to that element, or to it’s inverse.
- If a group is cyclic, then it is *abelian* (/aka/ *commutative*, $(a \cdot b = b \cdot a$)).
- Finite and infinite cyclic groups
  - *Finite cyclic group*: $G = \{ e, g, g^2, \dots, g^{n-1} \}$, where $g^n = e$.
    Example: $\mathbb{Z}/n\mathbb{Z}$ (integers modulo $n$ under addition).
  - *Infinite cyclic group*: $G = \{ \dots, g^{-2}, g^{-1}, e, g, g^2, \dots \}$.
    Example: $\mathbb{Z}$ (integers under addition).

- Example: [[file:~/CloudStation/Cryptography_101/zkSNARKs-notes/algebra.org::*Primitive Roots][Primitive Roots]] modulo $n$ generate a multiplicative group of integers modulo $n$

#+BEGIN_SRC sage :session . :exports both
q=7
F = GF(q)
[x for x in F if x.is_primitive_root()]

# or by hand

Z = Zmod(q)
G = Z.unit_group() # multiplicative group mod 7

Z
[x for x in Z]
G
[x for x in G]

G.inject_variables()

primitive_roots = []

for x in G:
  elem = Z(x)
  generates = set()
  for i in range(1,q):
    generates.add(elem^i)
  print(f"element {elem} generates {generates}")
  if len(generates) == G.order():
    primitive_roots.append(elem)

print(f"primitive roots of Z7^*: {primitive_roots}")

#+END_SRC

#+RESULTS:
#+begin_example
[3, 5]
Ring of integers modulo 7
[0, 1, 2, 3, 4, 5, 6]
Multiplicative Abelian group isomorphic to C6
[1, f, f^2, f^3, f^4, f^5]
Defining f
element 1 generates {1}
element 3 generates {1, 2, 3, 4, 5, 6}
element 2 generates {1, 2, 4}
element 6 generates {1, 6}
element 4 generates {1, 2, 4}
element 5 generates {1, 2, 3, 4, 5, 6}
primitive roots of Z7^*: [3, 5]
#+end_example

*** IN-PROGRESS Integers with Modulo Addition

- The group $(\mathbb{Z}/n\mathbb{Z}, +)$ (integers modulo $n$ under addition) is *always cyclic* for any $n \geq 1$.
- The element $1$ (or any integer coprime to $n$) generates the entire group.
- Example: $\mathbb{Z}/4\mathbb{Z} = \{0, 1, 2, 3\}$:
    - $1^1 = 1, \quad 1^2 = 2, \quad 1^3 = 3, \quad 1^4 = 0$
    - $3^1 = 2, \quad 3^2 = 1, \quad 3^3 = 3, \quad 3^4=0$
    - If 3 is coprime to 4 (i.e. gcd(3, 4) = 1), therefore 3 is also a generator.

#+BEGIN_SRC sage :session . :exports both
n=4
Zn = AdditiveAbelianGroup([n])
Zn
[x for x in Z4]
Zn.gens()

generators = []

for elem in Zn:
  generates = set()
  for i in range(1,n+1):
    generates.add(elem * i)
  print(f"element {elem} generates {generates}")
  if len(generates) == Zn.order():
    generators.append(elem)

print(f"generators of Z/{n}Z: {generators}")
#+END_SRC

#+RESULTS:
: Additive abelian group isomorphic to Z/4
: [(0), (1), (2), (3)]
: ((1),)
: element (0) generates {(0)}
: element (1) generates {(0), (1), (2), (3)}
: element (2) generates {(0), (2)}
: element (3) generates {(0), (1), (2), (3)}
: generators of Z/4Z: [(1), (3)]

** DONE Exercises
*** DONE Show that the set $\{1\}$ with the binary operator $\times$ is a group.

- Closure: $1 \times 1 = 1$
- Associativity: $(1 \times 1) \times 1 = 1 \times (1 \times 1)$
- Identity element is $1$ since: $1 \times 1 = 1$
- Inverse: $1 \times 1 = 1$

- It is also abelian:
  - Commutativity: $1 \times 1 = 1 \times 1$

*** DONE Integers (positive and negative) are not a group under multiplication. Show which of the four requirements (closed, associative, existence of identity, all elements having an inverse) are not satisfied

- Closure: $\forall a,b \in \mathbb{Z} \hspace{.5em} a \cdot b \in \mathbb{Z}$
- Associativity: $\forall a,b,c \in \mathbb{Z} \hspace{.5em} (a \cdot b) \cdot c = a \cdot (b \cdot c)$
- Identity element: $\exists 1 \in \mathbb{Z} \hspace{.5em} \text{ s.t. } a \cdot 1 = a$
- Inverse:
  - 0 has no multiplicative inverse in \mathbb{Z}: $0 \cdot a^{-1} = 1 \hspace{1em} \Rightarrow \hspace{1em} 0 = 1$. Contradiction.
  - 2 has no multiplictive inverse in \mathbb{Z}:  $2 \cdot a^{-1} = 1 \hspace{1em} \Leftrightarrow \hspace{1em} a^{-1} = \frac{1}{2} \notin \mathbb{Z}$.

* IN-PROGRESS Pre-course problem set
** DONE Suppose you have a set A={monyet, kodok, burung, ular}. Define a binary operator that turns it into a group using set-theoretic definitions

- Choose one element as identity and fill the column for the identity element such that if a * e = a then e*a = a where e is the assigned inverse.
  - for example: kodok is the identity element
  - this defines the row and column for the identity element
- Fill the rest of the table (9 entries), there are two cases here:
  1. We choose the group generator and assign such that g^1 = g, g^2 = a_1, g^3 = a_2, g^4 = a_3
     - e.g. monyet is the generator: monyet^1 = monyet, monyet^2 = burung, monyet^3 = ular, monyet^4 = e
     - this forces the choice of inverses:
     - m^3 = u <=> m^4 * m^-1 = u <=> m^2 * m^2 * m^-1 = u <-> b * b * m^-1 = u <=> k * m^-1 = u <=> m^-1 = u (therefore m * u = k)
     - m^4 = k <=> m^2 * m^2 = k <=> b * b = k
     - b * b = k <=> b = k * b^-1 <=> b^-1 = b (b * b =k)
     - ...
  2. We assign such that non-identity elements are self-inverses: monyet^2 = burung^2 = ular^2 = kodok^2 = e)
+- Ensure associativity: define products such that if a1 * a2 = a3 then a2 * a1 = a3 also.+
- Other solutions are isomorphic by relabeling
- Each row and column is the permutation of the elements (because of the inverses)

*Case 1:*

| $*$    | monyet | kodok  | burung | ular   |
| monyet | burung | monyet | ular   | kodok  |
| kodok  | monyet | kodok  | burung | ular   |
| burung | ular   | burung | kodok  | monyet |
| ular   | kodok  | ular   | monyet | burung |

*Case 2:*

| $*$    | monyet | kodok  | burung | ular   |
| monyet | kodok  | monyet | ular   | burung |
| kodok  | monyet | kodok  | burung | ular   |
| burung | ular   | burung | kodok  | monyet |
| ular   | burung | ular   | monyet | kodok  |

*Set-theory operator (case 2)*

|                  | monyet                     | kodok                      | burung                     | ular                      |
|------------------+----------------------------+----------------------------+----------------------------+---------------------------|
| (monyet, monyet) | ((monyet, monyet),monyet)  | *((monyet, monyet),kodok)* | ((monyet, monyet),burung)  | ((monyet, monyet),ular)   |
| (monyet, kodok)  | *((monyet, kodok),monyet)* | ((monyet, kodok),kodok)    | ((monyet, kodok),burung)   | ((monyet, kodok),ular)    |
| (monyet, burung) | ((monyet, burung),monyet)  | ((monyet, burung),kodok)   | ((monyet, burung),burung)  | *((monyet, burung),ular)* |
| (monyet, ular)   | ((monyet, ular),monyet)    | ((monyet, ular),kodok)     | *((monyet, ular),burung)*  | ((monyet, ular),ular)     |
| (kodok, monyet)  | *((kodok, monyet),monyet)* | ((kodok, monyet),kodok)    | ((kodok, monyet),burung)   | ((kodok, monyet),ular)    |
| (kodok, kodok)   | ((kodok, kodok),monyet)    | *((kodok, kodok),kodok)*   | ((kodok, kodok),burung)    | ((kodok, kodok),ular)     |
| (kodok, burung)  | ((kodok, burung),monyet)   | ((kodok, burung),kodok)    | *((kodok, burung),burung)* | ((kodok, burung),ular)    |
| (kodok, ular)    | ((kodok, ular),monyet)     | ((kodok, ular),kodok)      | ((kodok, ular),burung)     | *((kodok, ular),ular)*    |
| (burung, monyet) | ((burung, monyet),monyet)  | ((burung, monyet),kodok)   | ((burung, monyet),burung)  | *((burung, monyet),ular)* |
| (burung, kodok)  | ((burung, kodok),monyet)   | ((burung, kodok),kodok)    | *((burung, kodok),burung)* | ((burung, kodok),ular)    |
| (burung, burung) | ((burung, burung),monyet)  | *((burung, burung),kodok)* | ((burung, burung),burung)  | ((burung, burung),ular)   |
| (burung, ular)   | *((burung, ular),monyet)*  | ((burung, ular),kodok)     | ((burung, ular),burung)    | ((burung, ular),ular)     |
| (ular, monyet)   | ((ular, monyet),monyet)    | ((ular, monyet),kodok)     | *((ular, monyet),burung)*  | ((ular, monyet),ular)     |
| (ular, kodok)    | ((ular, kodok),monyet)     | ((ular, kodok),kodok)      | ((ular, kodok),burung)     | *((ular, kodok),ular)*    |
| (ular, burung)   | *((ular, burung),monyet)*  | ((ular, burung),kodok)     | ((ular, burung),burung)    | ((ular, burung),ular)     |
| (ular, ular)     | ((ular, ular),monyet)      | *((ular, ular),kodok)*     | ((ular, ular),burung)      | ((ular, ular),ular)       |

- *Closure*: $\forall a,b \in F \hspace{.5em} (a * b) \in F$
- *Associativity*: manual check on a 4C3 = 4 (a subset):
  - (monyet * kodok)  * burung = monyet * (kodok  * burung) <=> ular = ular
  - (monyet * burung) * ular   = monyet * (burung * ular)   <=> kodok = kodok
  - (kodok  * burung) * ular   = kodok  * (burung * ular)   <=> monyet = monyet
  - (ular   * monyet) * kodok  = ular   * (monyet * kodok)  <=> burung = burung
- *Identity element*: kodok (by choice)
- *Inverses*:
  - monyet^{-1} = monyet
  - kodok^{-1}  = kodok
  - burung^{-1} = burung
  - ular^{-1}   = ular

** DONE Find a binary operator that is closed but not associative for real numbers

For example $f: \mathbb{R} \times \mathbb{R} -> \mathbb{R}$ s.t f(a,b) = exp(a*b)

#+BEGIN_SRC jupyter-python :session zk :async yes
import numpy as np
a=1;b=2;c=3

def f(a,b):
  return np.exp(a * b)

f(f(a,b),c) == f(a,f(b,c))
#+END_SRC

#+RESULTS:
: False

Another example is f(a,b) = a^b:

#+BEGIN_SRC jupyter-python :session zk :async yes
import numpy as np
a=2;b=3;c=2

def g(a,b):
  return np.power(a,b)

g(g(a,b),c) == g(a,g(b,c))
#+END_SRC

#+RESULTS:
: False

** DONE Let our set be real numbers. Show a binary operator that is not closed

$f(a,b)=\sqrt{a} + \sqrt{b}$ is a binary operator that is not closed:

$f(4,-1) = \sqrt{2} + \sqrt{-1} = 2+i \notin \mathbb{R}$

** DONE What algebraic structure is all odd integers under multiplication? All even integers under addition?

The set of integers not divisible by $2$ (odd integers): $A=\{x \in \mathbb{Z}: \hspace{.5em} \exists{k} \in N: \hspace{.5em} x=2k+1 \}=\{-5, -3,-1,1,3,5, \ldots \}$ under multiplications is:

- *closed*: odd numbers multiplied by odd numbers are odd
- *associative*: generally holds for multiplication
- *identity*: $1$ is the identity element
- *existence of inverse elements*:
  - take $3 \in A$ there is no $3^{-1} \in A$ such that $3*3^{-1} =1$

Such a structure is called a *monoid*

The set of integers divisible by $2$ (even): $B=\{x \in \mathbb{Z}: \hspace{.5em} \exists{k} \in N: \hspace{.5em} x=2k \} = \{ -4,-2,0,2,4, \ldots \}$ under addition is:

- *closed*: even numbers multiplied by even numbers are even
- *associative*: holds for addition
- *identity*: $0$ is the identity element
- *existence of inverse elements*: for every $x \in B$ $-x \in B$ is the inverse.

This is a group

** IN-PROGRESS Let our group be 3 x 2 matrices of integers under addition. What is the identity and inverse? Can this be a cyclic group, why or why not? (Pay very close attention to the definition of a cyclic group)

- *identity*: matrix $E=\begin{bmatrix} 0 & 0  \\ 0 & 0  \\0 & 0 \end{bmatrix}$ of all $0$'s is the identity element
- *existence of inverse elements*: For every $M=\begin{bmatrix} m_{11} & m_{12}  \\ m_{21} & m_{22}  \\ m_{31} & m_{32} \end{bmatrix}$ matrix $-M$ is it's inverse.

- *cyclic*: The group is not cyclic, because there is no generator.

#+BEGIN_SRC jupyter-python :session zk :async yes
  import numpy as np
  import random

  np.random.seed(2137)

  # identity element
  e = np.array([
                [0,0],
                [0,0],
                [0,0]
               ])

  # random element
  m = np.array([
                [random.randint(-10,10), random.randint(-10,10)],
                [random.randint(-10,10), random.randint(-10,10)],
                [random.randint(-10,10), random.randint(-10,10)]
               ])

  # e is the identity element
  assert((m + e == m).all())

  # negated m is the inverse
  assert((m + -m == e).all())
#+END_SRC

#+RESULTS:
