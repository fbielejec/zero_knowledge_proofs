* NOTES
- powers of tau
- degree of the polynomials l,r,o,h,T
- proving QAP
  - trusted setup
  - proof generation
  - proof check via pairings
- srs
- verifying polynomial equality in ZK (using EC)
- chapters
  - https://rareskills.io/post/elliptic-curve-qaphttps://rareskills.io/post/elliptic-curve-qap
  - https://rareskills.io/post/trusted-setup

#+BEGIN_SRC sage :session . :exports both
import numpy as np
import random
import py_ecc.bn128 as bn128
from py_ecc.fields import (
      bn128_FQ as FQ,
      bn128_FQ2 as FQ2,
      bn128_FQ12 as FQ12
)

p = 21888242871839275222246405745257275088696311157297823662689037894645226208583
Fp = GF(p)
E = EllipticCurve(Fp, [0,3])
G1 = E(1,2)
k = 2
Rx.<x> = Fp[]
Fp2 = GF(p^k, name = 'i', modulus = x^k + 1)

# https://eips.ethereum.org/EIPS/eip-197#:~:text=q%20%3D%2021888242871839275222246405745257275088548364400416034343698204186575808495617.-,Definition%20of%20the%20groups,-The%20groups%20G_1
a=0
TwistB=3*Fp2([9,1])^(-1) # 3/(i+9)
E2 = EllipticCurve(Fp2, [a,TwistB])

# [a,b] -> a + i*b
x_G2 = Fp2([
      10857046999023057135944570762232829481370756359578518086990519993285655852781,
      11559732032986387107991004021392285783925812861821192530917403151452391805634
])

y_G2 = Fp2([
      8495653923123431417604973247489272438418190587263600148770280649306958101930,
      4082367875863433681332203403145435568316851327593401208105741076214120093531
])

G2 = E2(x_G2, y_G2)

# computes e(Q \in G2, P \in G1)
# returns an element in FQ12 (extension tower Fp^2 -> Fp^6 -> Fp12)
def pairing(P,Q):
    ePQ = bn128.pairing((bn128.FQ2([int(Q[0][0]), int(Q[0][1])]),
                         bn128.FQ2([int(Q[1][0]), int(Q[1][1])])),
                        (bn128.FQ(int(P[0])), bn128.FQ(int(P[1]))));
    return ePQ

# pick values for x (xw) and y (yw)
xw = 100
yw = 100

# this is our original formula
out = 3 * xw * xw * yw + 5 * xw * yw - xw - 2*yw + 3

v1 = 3*xw*xw
v2 = v1 * yw

# --- witness vector

w = np.array([1, out, xw, yw, v1, v2])

# Define the matrices for R1CS
L = np.array([[Fp(0),Fp(0),Fp(3),Fp(0),Fp(0),Fp(0)],
              [Fp(0),Fp(0),Fp(0),Fp(0),Fp(1),Fp(0)],
              [Fp(0),Fp(0),Fp(1),Fp(0),Fp(0),Fp(0)]])

R = np.array([[Fp(0),Fp(0),Fp(1),Fp(0),Fp(0),Fp(0)],
              [Fp(0),Fp(0),Fp(0),Fp(1),Fp(0),Fp(0)],
              [Fp(0),Fp(0),Fp(0),Fp(5),Fp(0),Fp(0)]])

O = np.array([[Fp(0),Fp(0),Fp(0),Fp(0),Fp(1),Fp(0)],
              [Fp(0),Fp(0),Fp(0),Fp(0),Fp(0),Fp(1)],
              [Fp(-3),Fp(1),Fp(1),Fp(2),Fp(0),Fp(-1)]])

# check r1cs
O.dot(w) == np.multiply(L.dot(w),R.dot(w))

# --- QAP ---

# interpolation set
# TODO : generate based on ncol
xs = [Fp(1),Fp(2),Fp(3)]

us = []
for col in np.matrix.transpose(np.array(L)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  us.append(p)

vs = []
for col in np.matrix.transpose(np.array(R)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  vs.append(p)

ws = []
for col in np.matrix.transpose(np.array(O)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  ws.append(p)

l = np.dot(us, w)
r = np.dot(vs, w)
o = np.dot(ws, w)

# check interpolation l(x) * r(x) = o(x) in x=[1,2,3]
l(xs[0]) * r(xs[0]) == o(xs[0])
l(xs[1]) * r(xs[1]) == o(xs[1])
l(xs[2]) * r(xs[2]) == o(xs[2])

# TODO: generate based on the interpolation set
T = (x-xs[0])*(x-xs[1])*(x-xs[2])

h = (l*r-o)//T
# remainder should be 0
remainder = (l*r - o) % T

remainder == 0

# --- trusted setup ---

# random tau (unknown to the prover and verifier)
random.seed(int(2137))
tau = Fp(random.randint(1, E.order()))

# check QAP non-succintly
l * r - o == T*h

# check QAP succintly using SZ lemma (assuming we know tau, although we dont)
l(tau) * r(tau) - o(tau) == T(tau)*h(tau)

# 1*G1, tau*G1, tau^2*G1, ...
SRS1 = [G1 * tau**i for i in range(len (L))]

# 1*G2, tau*G2, tau^2*G2, ...
SRS2 = [G2 * tau**i for i in range(len (R))]

# T(tau)*G1, T(tau)*t*G1, T(tau)*t^2*G1, ...
SRS3 = [G1 * T(tau) * tau**i for i in range(len (L)-1)]

# --- proving QAP using the trusted setup (prover does not know tau, but he knows the powers of tau)

# l(x) = a + b*x + c*x^2 + ... + d*x^(n-1)
# A = l(tau)G1 = a * tau^0*G1 + b*tau*G1 + c*tau^2*G1 + ...
#A = E(0)
# coeff order needs to match the SRS order! (low powers to high)
#lcoeff = l.coefficients()
#lcoeff.reverse()
#for i in range(len(SRS1)):
#  A = A + lcoeff[i] * SRS1[i]

### -- START : tmp

rtaus=[0,0,0]
for i in range(len(SRS2)):
  rtaus[i]=r.coefficients()[i] * SRS2[i]  


#rtau == G2*r(tau)

### --- END

# check
#A == G1*l(tau)
#
## evaluate r(tau) in the same manner
#B = E2(0)
#rcoeff = r.coefficients()
## rcoeff.reverse()
#for i in range(len(SRS2)):
#  B = B + rcoeff[i] * SRS2[i]
#
## check
#B == G2*r(tau)
#
## --- C = o(tau)G1 + h(tau)*T(tau)*G1
#
#otau = E(0)
#ocoeff = o.coefficients()
## ocoeff.reverse()
#for i in range(len(SRS1)):
#  otau = otau + ocoeff[i] * SRS1[i]
#
## check
#otau == G1*o(tau)
#
## h(x)T(x) = (a + b*x + c*x^2 + ...) * T(x) = a * T(x)
#hTtau=E(0)
#hcoeff = h.coefficients()
## hcoeff.reverse()
#for i in range(len(SRS3)):
#  hTtau = hTtau + hcoeff[i] * SRS3[i]
#
##check
#hTtau == h(tau)*T(tau)*G1
#
#C = otau + hTtau

# TODO : verify (using pairings)
# TODO: fails, why?

#pairing(A,B) == pairing(C,G2)

#+END_SRC

#+RESULTS:
: array([ True,  True,  True])
: True
: True
: True
: True
: True
: True
: False
