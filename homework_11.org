* TODO hw 11
- https://almondine-song-c43.notion.site/Homework-10-4d75259eac0246aa86ed48b51e7700b6

#+BEGIN_SRC sage :session . :exports both
import numpy as np
import random
import py_ecc.bn128 as bn128
from py_ecc.fields import (
      bn128_FQ as FQ,
      bn128_FQ2 as FQ2,
      bn128_FQ12 as FQ12,
)

p = 21888242871839275222246405745257275088696311157297823662689037894645226208583
Fp = GF(p)
E = EllipticCurve(Fp, [0,3])
G1 = E(1,2)

r = E.order()             # group order (Fr modulus)
Fr = GF(r)                # scalar field
Rx_fr = Fr['x']           # polynomial ring over Fr
x = Rx_fr.gen()

k = 2
Fp2 = GF(p^k, name = 'i', modulus = x^k + 1)

# https://eips.ethereum.org/EIPS/eip-197#:~:text=q%20%3D%2021888242871839275222246405745257275088548364400416034343698204186575808495617.-,Definition%20of%20the%20groups,-The%20groups%20G_1
a=0
TwistB=3*Fp2([9,1])^(-1) # 3/(i+9)
E2 = EllipticCurve(Fp2, [a,TwistB])

# [a,b] -> a + i*b
x_G2 = Fp2([
      10857046999023057135944570762232829481370756359578518086990519993285655852781,
      11559732032986387107991004021392285783925812861821192530917403151452391805634
])

y_G2 = Fp2([
      8495653923123431417604973247489272438418190587263600148770280649306958101930,
      4082367875863433681332203403145435568316851327593401208105741076214120093531
])

G2 = E2(x_G2, y_G2)

# computes e(P \in G1, Q \in G2)
# returns an element in FQ12 (extension tower Fp^2 -> Fp^6 -> Fp12)
def pairing(P_G1,Q_G2):
    ePQ = bn128.pairing((bn128.FQ2([int(Q_G2[0][0]), int(Q_G2[0][1])]),
                         bn128.FQ2([int(Q_G2[1][0]), int(Q_G2[1][1])])),
                        (bn128.FQ(int(P_G1[0])), bn128.FQ(int(P_G1[1]))));
    return ePQ

# --- STATEMENT:
# I know 4 numbers a1*a2*a3*a4 = 48"
a1=6; a2=2; a3=2; a4=2; a5=12; a6=4

assert(a1*a2==a5)
assert(a3*a4==a6)
assert(a5*a6==48)

# the witness:
a = np.array([1, a1, a2, a3, a4, a5, a6])

# --- R1CS constraints
L = np.array([[0,1,0,0,0,0,0],[0,0,0,1,0,0,0],[0,0,0,0,0,1,0]])
R = np.array([[0,0,1,0,0,0,0],[0,0,0,0,1,0,0],[0,0,0,0,0,0,1]])
O = np.array([[0,0,0,0,0,1,0],[0,0,0,0,0,0,1],[48,0,0,0,0,0,0]])

# check r1cs
assert (all(O.dot(a) == np.multiply(L.dot(a), R.dot(a))))

# --- QAP ---

m = len(L)                # number of constraints

# interpolation points in Fr
xs_fr = [Fr(i) for i in range(m)]

us = []
for col in np.matrix.transpose(np.array(L)):
    p = Rx_fr.lagrange_polynomial(zip(xs_fr, [Fr(int(c)) for c in col]))
    us.append(p)

vs = []
for col in np.matrix.transpose(np.array(R)):
  vs.append(Rx_fr.lagrange_polynomial(zip(xs_fr, [Fr(int(c)) for c in col])))

ws = []
for col in np.matrix.transpose(np.array(O)):
  ws.append(Rx_fr.lagrange_polynomial(zip(xs_fr, [Fr(int(c)) for c in col])))

# compute l,r,o in Fr[x]

a_fr = [Fr(int(v)) for v in a]   # witness as Fr elements

# compute l,r,o in Fr[x]
l = sum(u * ai for u, ai in zip(us, a_fr))
r = sum(v * ai for v, ai in zip(vs, a_fr))
o = sum(w * ai for w, ai in zip(ws, a_fr))

# check interpolation l(x) * r(x) = o(x) for x in the interpolation set
[l(x) * r(x) == o(x) for x in xs_fr]

T = math.prod(x - xi for xi in xs_fr)

# calculate h
h = (l*r-o)//T

remainder = (l*r - o) % T

# remainder should be 0 (when the witness is correct)
assert (remainder == 0)

# --- TRUSTED SETUP ---
#
## random tau (unknown to the prover and verifier)
random.seed(int(2137))
tau = random.randint(1, E.order())
tau_int = int(tau)        # ensure it's in 0..r-1
tau_fr  = Fr(tau_int)     # element of Fr for polynomial evaluation if needed

#
# check QAP non-succintly (in every point)
assert(l * r - o == T*h)

# check QAP succintly (using SZ lemma and assuming verifier knows tau)
assert(l(tau) * r(tau) - o(tau) == T(tau)*h(tau))

deg_l = len(l.coefficients())
deg_r = len(r.coefficients())
deg_o = len(o.coefficients())
deg_h = len(h.coefficients())

# build SRS with integer powers (group scalars are integers modulo r)

# 1*G1, tau*G1, tau^2*G1, ...
SRS1 = [ (tau_int**i) * G1 for i in range(max(deg_l, deg_o)) ]
# 1*G2, tau*G2, tau^2*G2, ...
SRS2 = [(tau_int**i) * G2 for i in range(deg_r)]
# T(tau)*G1, T(tau)*t*G1, T(tau)*t^2*G1, ...
T_val = Fr(T(tau_int))
SRS3 = [(T_val * (tau_int**i)) * G1 for i in range(deg_h)]

# --- proving QAP using the trusted setup (prover does not know tau, but he knows the powers of tau)

# commit to a polynomial (in Fr[x]) using SRS
def commit(poly, srs):
    coeffs = poly.coefficients()   # elements in Fr
    # convert each Fr element to its canonical integer representative 0..r-1
    return sum( int(ci) % E.order() * srs[i] for i, ci in enumerate(coeffs) )

ltau = commit(l, SRS1)
ltau == (int(l(tau_fr)) % E.order()) * G1

rtau = commit(r, SRS2)
rtau == r(tau) * G2

otau = commit(o, SRS1)
otau == o(tau) * G1

hTtau = commit(h, SRS3)

# verify
pairing(ltau,rtau) == pairing(otau + hTtau,G2)
#+END_SRC

#+RESULTS:
: [True, True, True]
: True
: True
: True
: True
