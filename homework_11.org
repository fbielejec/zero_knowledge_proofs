* TODO hw 11
- https://almondine-song-c43.notion.site/Homework-10-4d75259eac0246aa86ed48b51e7700b6

#+BEGIN_SRC sage :session . :exports both
import numpy as np
import random
import py_ecc.bn128 as bn128
from py_ecc.fields import (
      bn128_FQ as FQ,
      bn128_FQ2 as FQ2,
      bn128_FQ12 as FQ12,
)

p = 21888242871839275222246405745257275088696311157297823662689037894645226208583
Fp = GF(p)
E = EllipticCurve(Fp, [0,3])
G1 = E(1,2)
k = 2
Rx.<x> = Fp[]
Fp2 = GF(p^k, name = 'i', modulus = x^k + 1)

# https://eips.ethereum.org/EIPS/eip-197#:~:text=q%20%3D%2021888242871839275222246405745257275088548364400416034343698204186575808495617.-,Definition%20of%20the%20groups,-The%20groups%20G_1
a=0
TwistB=3*Fp2([9,1])^(-1) # 3/(i+9)
E2 = EllipticCurve(Fp2, [a,TwistB])

# [a,b] -> a + i*b
x_G2 = Fp2([
      10857046999023057135944570762232829481370756359578518086990519993285655852781,
      11559732032986387107991004021392285783925812861821192530917403151452391805634
])

y_G2 = Fp2([
      8495653923123431417604973247489272438418190587263600148770280649306958101930,
      4082367875863433681332203403145435568316851327593401208105741076214120093531
])

G2 = E2(x_G2, y_G2)

# computes e(Q \in G2, P \in G1)
# returns an element in FQ12 (extension tower Fp^2 -> Fp^6 -> Fp12)
def pairing(P,Q):
    ePQ = bn128.pairing((bn128.FQ2([int(Q[0][0]), int(Q[0][1])]),
                         bn128.FQ2([int(Q[1][0]), int(Q[1][1])])),
                        (bn128.FQ(int(P[0])), bn128.FQ(int(P[1]))));
    return ePQ

# --- STATEMENT:
# I know 4 numbers a1*a2*a3*a4 = 48"
a1=6; a2=2; a3=2; a4=2; a5=12; a6=4

a1*a2==a5
a3*a4==a6
a5*a6==48

# the witness:
a = np.array([1, a1, a2, a3, a4, a5, a6])

# --- R1CS constraints
L = np.array([[0,1,0,0,0,0,0],[0,0,0,1,0,0,0],[0,0,0,0,0,1,0]])
R = np.array([[0,0,1,0,0,0,0],[0,0,0,0,1,0,0],[0,0,0,0,0,0,1]])
O = np.array([[0,0,0,0,0,1,0],[0,0,0,0,0,0,1],[48,0,0,0,0,0,0]])

# check r1cs
O.dot(a) == np.multiply(L.dot(a),R.dot(a))

# --- QAP ---

# interpolation set x in 0 ... #constraints
xs = [Fp(i) for i in range(0,len(L))]
xs

us = []
for col in np.matrix.transpose(np.array(L)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  us.append(p)

vs = []
for col in np.matrix.transpose(np.array(R)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  vs.append(p)

ws = []
for col in np.matrix.transpose(np.array(O)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  ws.append(p)

l = np.dot(us, a)
r = np.dot(vs, a)
o = np.dot(ws, a)

# check interpolation l(x) * r(x) = o(x) for x in the interpolation set
[l(x) * r(x) == o(x) for x in xs]

T = math.prod(x - xi for xi in xs)

# calculate h
h = (l*r-o)//T

remainder = (l*r - o) % T

# remainder should be 0 (when the witness is correct)
remainder == 0

# --- TRUSTED SETUP ---

# random tau (unknown to the prover and verifier)
random.seed(int(2137))
tau = random.randint(1, E.order())

# check QAP non-succintly (in every point)
l * r - o == T*h

# check QAP succintly (using SZ lemma and assuming verifier knows tau)
l(tau) * r(tau) - o(tau) == T(tau)*h(tau)

# 1*G1, tau*G1, tau^2*G1, ...
SRS1 = [G1 * (tau**i) for i in range(len (L))]
# 1*G2, tau*G2, tau^2*G2, ...
SRS2 = [G2 * tau**i for i in range(len (L))]
# T(tau)*G1, T(tau)*t*G1, T(tau)*t^2*G1, ...
SRS3 = [G1 * T(tau) * tau**i for i in range(len (L)-1)]

# --- proving QAP using the trusted setup (prover does not know tau, but he knows the powers of tau)

# l(x) = a + b*x + c*x^2 + ... + d*x^(n-1)
# l(tau) * G1 = a * tau^0*G1 + b*tau*G1 + c*tau^2*G1 + ...
ltau = E(0)
# pad with 0's in case the lagrange polynomial has degree less than m
lcoeffs = l.coefficients()
lcoeffs = np.pad(lcoeffs, (0, len(SRS1) - len(lcoeffs)))
for i in range(len(SRS1)):
  ltau = ltau + SRS1[i]* lcoeffs[i]

# ltau == l(tau)*G1

rtau = E2(0)
rcoeffs = r.coefficients()
rcoeffs = np.pad(rcoeffs, (0, len(SRS2) - len(rcoeffs)))
for i in range(len(SRS2)):
  rtau = rtau + SRS2[i]* rcoeffs[i]

#rtau == r(tau)*G2

otau = E(0)
ocoeffs = o.coefficients()
ocoeffs = np.pad(ocoeffs, (0, len(SRS1) - len(ocoeffs)))
for i in range(len(SRS1)):
  otau = otau + SRS1[i]* ocoeffs[i]

#otau == o(tau)*G1

# h(x)T(x) = (a + b*x + c*x^2 + ...) * T(x) = a * T(x)
hTtau=E(0)
hcoeffs = h.coefficients()
hcoeffs = np.pad(hcoeffs, (0, len(SRS3) - len(hcoeffs)))
for i in range(len(SRS3)):
  hTtau = hTtau + hcoeff[i] * SRS3[i]

# verify

pairing(ltau,rtau) == pairing(otau + hTtau,G2)

#+END_SRC

#+RESULTS:
: True
: True
: True
: array([ True,  True,  True])
: [0, 1, 2]
: [True, True, True]
: True
: True
: True
