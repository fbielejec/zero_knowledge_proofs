* IN-PROGRESS Homework 10
- https://almondine-song-c43.notion.site/Homework-9-9142687e4ff94bda967f088a36cff41d
** DONE Convert the following R1CS into a QAP over real numbers field

#+BEGIN_SRC sage :session . :exports both
import numpy as np
import random

# Define the matrices
A = np.array([[0,0,3,0,0,0],
              [0,0,0,0,1,0],
              [0,0,1,0,0,0]])

B = np.array([[0,0,1,0,0,0],
              [0,0,0,1,0,0],
              [0,0,0,5,0,0]])

C = np.array([[0,0,0,0,1,0],
              [0,0,0,0,0,1],
              [-3,1,1,2,0,-1]])

# pick values for x and y
x = 100
y = 100

# this is our orignal formula
out = 3 * x * x * y + 5 * x * y - x- 2*y + 3# the witness vector with the intermediate variables inside
v1 = 3*x*x
v2 = v1 * y
w = np.array([1, out, x, y, v1, v2])

result = C.dot(w) == np.multiply(A.dot(w),B.dot(w))
assert result.all(), "result contains an inequality"
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sage :session . :exports both
FR = RationalField()
Rx.<x> = PolynomialRing(FR)

xs = [1,2,3]

us = []
for col in np.matrix.transpose(np.array(A)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  us.append(p)

us

vs = []
for col in np.matrix.transpose(np.array(B)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  vs.append(p)

vs

ws = []
for col in np.matrix.transpose(np.array(C)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  ws.append(p)

ws

# check l(x) * r(x) = o(x) in x=[1,2,3]

l = np.dot(us, w)
r = np.dot(vs, w)
o = np.dot(ws, w)

l(1) * r(1) == o(1)
l(2) * r(2) == o(2)
l(3) * r(3) == o(3)

# construct QAP
T=(x-1)*(x-2)*(x-3)

h=(l*r-o)/T
h

# QAP should hold almost everywhere, especially in a random point:
tau = random.randint(-1000,1000)

l(tau) * r(tau) == o(tau) + T(tau)*h(tau)
#+END_SRC

#+RESULTS:
#+begin_example
[0, 0, 2*x^2 - 9*x + 10, 0, -x^2 + 4*x - 3, 0]
[0, 0, 1/2*x^2 - 5/2*x + 3, 3/2*x^2 - 7/2*x + 2, 0, 0]
[-3/2*x^2 + 9/2*x - 3,
 1/2*x^2 - 3/2*x + 1,
 1/2*x^2 - 3/2*x + 1,
 x^2 - 3*x + 2,
 1/2*x^2 - 5/2*x + 3,
 -3/2*x^2 + 11/2*x - 4]
True
True
True
-5960000*x + 5940000
True
#+end_example

** DONE QAP over a finite field

#+BEGIN_SRC sage :session . :exports both
import numpy as np
import random

p=79
Fp=GF(p)
Rt.<t> = PolynomialRing(Fp)

# Define the matrices
A = np.array([[Fp(0),Fp(0),Fp(3),Fp(0),Fp(0),Fp(0)],
              [Fp(0),Fp(0),Fp(0),Fp(0),Fp(1),Fp(0)],
              [Fp(0),Fp(0),Fp(1),Fp(0),Fp(0),Fp(0)]])

B = np.array([[Fp(0),Fp(0),Fp(1),Fp(0),Fp(0),Fp(0)],
              [Fp(0),Fp(0),Fp(0),Fp(1),Fp(0),Fp(0)],
              [Fp(0),Fp(0),Fp(0),Fp(5),Fp(0),Fp(0)]])

C = np.array([[Fp(0),Fp(0),Fp(0),Fp(0),Fp(1),Fp(0)],
              [Fp(0),Fp(0),Fp(0),Fp(0),Fp(0),Fp(1)],
              [Fp(-3),Fp(1),Fp(1),Fp(2),Fp(0),Fp(-1)]])

# pick values for x and y
x = 100
y = 100

# this is our original formula
out = 3 * x * x * y + 5 * x * y - x- 2*y + 3# the witness vector with the intermediate variables inside
v1 = 3*x*x
v2 = v1 * y
w = np.array([1, out, x, y, v1, v2])

result = C.dot(w) == np.multiply(A.dot(w),B.dot(w))
assert result.all(), "result contains an inequality"

xs = [Fp(1),Fp(2),Fp(3)]

us = []
for col in np.matrix.transpose(np.array(A)):
  p = Rt.lagrange_polynomial(zip(xs,col))
  us.append(p)

us

vs = []
for col in np.matrix.transpose(np.array(B)):
  p = Rt.lagrange_polynomial(zip(xs,col))
  vs.append(p)

vs

ws = []
for col in np.matrix.transpose(np.array(C)):
  p = Rt.lagrange_polynomial(zip(xs,col))
  ws.append(p)

ws

l = np.dot(us, w)
r = np.dot(vs, w)
o = np.dot(ws, w)

l(1) * r(1) == o(1)
l(2) * r(2) == o(2)
l(3) * r(3) == o(3)

T=(t-1)*(t-2)*(t-3)

h=(l*r-o)/T
h

# QAP should hold almost everywhere, especially in a random point:
tau = random.randint(-1000,1000)

l(tau) * r(tau) == o(tau) + T(tau)*h(tau)
#+END_SRC

#+RESULTS:
#+begin_example
[0, 0, 2*t^2 + 70*t + 10, 0, 78*t^2 + 4*t + 76, 0]
[0, 0, 40*t^2 + 37*t + 3, 41*t^2 + 36*t + 2, 0, 0]
[38*t^2 + 44*t + 76,
 40*t^2 + 38*t + 1,
 40*t^2 + 38*t + 1,
 t^2 + 76*t + 2,
 40*t^2 + 37*t + 3,
 38*t^2 + 45*t + 75]
True
True
True
76*t + 69
True
#+end_example
