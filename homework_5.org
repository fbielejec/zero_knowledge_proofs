* IN-PROGRESS hw5
- https://almondine-song-c43.notion.site/Homework-5-961b5df93d0a4698963b88bf7ff94f84

** DONE Problem 1: Rational numbers

Weâ€™re going to do zero knowledge addition again.

Claim: "I know two rational numbers that add up to num/den"

Proof: ([A], [B], num, den)

Here, num is the numerator of the rational number and den is the denominator.

#+BEGIN_SRC Solidity
struct ECPoint {
        uint256 x;
        uint256 y;
}

function rationalAdd(ECPoint calldata A, ECPoint calldata B, uint256 num, uint256 den) public view returns (bool verified) {
// return true if the prover knows two numbers that add up to num/den
}
#+END_SRC

Solidity/EVM has two functions you may find handy: 'mulmod' (which does multiplication modulo p) and the precompile 'modExp' which does modular exponentiation.

Although 'modExp' does not let you raise to the power of -1, you can accomplish the same thing by raising a number to 'curve_order - 2'.

The following identity will be handy:

#+BEGIN_SRC
pow(a, -1, curve_order) == pow(a, curve_order - 2, curve_order)
#+END_SRC

(This is [[id:bfc4c13f-a0cf-4772-bdf9-1802b3ba7080][Fermat's Little Theorem]])

To accomplish 'pow' the precompile 'modExp' may be handy.

#+BEGIN_SRC Solidity
function modExp(uint256 base, uint256 exp, uint256 mod)
                public
                view
                returns (uint256) {

                bytes memory precompileData = abi.encode(32, 32, 32, base, exp, mod);
    (bool ok, bytes memory data) = address(5).staticcall(precompileData);
    require(ok, "expMod failed");
    return abi.decode(data, (uint256));
}
#+END_SRC

*** DONE Test data

#+BEGIN_SRC sage :session . :exports both
# bn128
q=21888242871839275222246405745257275088696311157297823662689037894645226208583
Fq=GF(q)
E = EllipticCurve(Fq, [0,3])
G = E(1,2)

a=2
b=3

A=a*G
B=b*G
A
B

# A + B == (a+b)*G

num = 10
den = 2

a*G + b*G == (Fq(num) * Fq(den)**(-1)) * G
#+END_SRC

#+RESULTS:
: (1368015179489954701390400359078579693043519447331113978918064868415326638035 : 9918110051302171585080402603319702774565515993150576347155970296011118125764 : 1)
: (3353031288059533942658390886683067124040920775575537747144343083137631628272 : 19321533766552368860946552437480515441416830039777911637913418824951667761761 : 1)
: True
: True

** IN-PROGRESS Problem 2: Matrix Multiplication

Your contract should implement matrix multiplication of an $n \times n$ matrix *M* of uint256 and a $n \times 1$ vector of points *s*.
It validates the claim that matrix $Ms = o$ where $o$ is a $n \tiomes 1$ matrix of uint256.
You will need to multiply *o* by the generator on-chain so that both sides have the same type.

#+BEGIN_SRC Solidity
struct ECPoint {
        uint256 x;
        uint256 y;
}

function matmul(uint256[] calldata matrix,
                uint256 n, // n x n for the matrix
                ECPoint[] calldata s, // n elements
                uint256[] calldata o // n elements
               ) public returns (bool verified) {

        // revert if dimensions don't make sense or the matrices are empty

        // return true if Ms == o elementwise. You need to do n equality checks. If you're lazy, you can hardcode n to 3, but it is suggested that you do this with a for loop
}
#+END_SRC

Example

$\begin{bmatrix}1 & 2 & 3\\4 & 5 & 6\\7 & 8 & 9\end{bmatrix}\begin{bmatrix}P\\Q\\R\end{bmatrix}=\begin{bmatrix}P+2Q+3R\\4P+5Q+6R\\7P + 8Q + 9R\end{bmatrix}\stackrel{?}{=}\begin{bmatrix}o_1G\\o_2G\\o_3G\end{bmatrix}#

*** DONE Test data

#+BEGIN_SRC sage :session . :exports both
# bn128
q=21888242871839275222246405745257275088696311157297823662689037894645226208583
Fq=GF(q)
E = EllipticCurve(Fq, [0,3])
G = E(1,2)

P=E.random_point()
Q=E.random_point()
R=E.random_point()

S=[P,Q,R]

m=[1,2,3,4,5,6,7,8,9]
n=3

O=[E(0),E(0),E(0)]
for row in range(n):
   for col in range(n):
    O[row] += m[row * n + col]*S[col]

assert([P   + 2*Q + 3*R,
      4*P + 5*Q + 6*R,
      7*P + 8*Q + 9*R] == O)

print(f"{m} * {S} = {O}")
#+END_SRC

#+RESULTS:
: [1, 2, 3, 4, 5, 6, 7, 8, 9] * [(13453625245081473323808800353457225167565869664644760646910557039566341930214 : 4227682114029646314567541970710863318074729154136213749391007310372880966063 : 1), (13431748881895426318069326578769457798764333156409950070530459285171032786037 : 4704746378805358354216631959117307222383707841904620695862391712577937195840 : 1), (542246685971526926955790925550598566272961373384322457226886801516496135350 : 1616604444639123685329550154354051286838809788250709485957146257190462073332 : 1)] = [(7843406726183644729962733009143868180751768152989834617602999229903720354689 : 2930821467562756099317560463796613837688069532298256649249574732410173337796 : 1), (19750369895990095041196183399446299252460406108354599543789655957052663063271 : 4119917742026983164507164225229661957678869616600866812842218745963928638665 : 1), (20943505874519370982289579286346864346779363188310902395911188101112078138376 : 20488305373412877235542367775854718351505179620887992476781792738262861432964 : 1)]
