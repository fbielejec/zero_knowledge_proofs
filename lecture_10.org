* NOTES
- QAP
- circuit - QAP
- succintness via SZ lemma
- https://rareskills.io/post/quadratic-arithmetic-program
- r1cs to QAP
- https://rareskills.io/post/r1cs-to-qap

** IN-PROGRESS R1CS to QAP (by hand)

I know $x,y,z$ s.t.

$x \cdot y \cdot z = 10$

In R1CS this becomes:

$\begin{cases}
x \cdot y = v_{1} \\
v_{1} \cdot z = 10
\end{cases}$

We will create a system of equations

where:
- $O,L,R$ are $n \times m $ matrices
- $w$ is the witness vector of length $m$ (here $m=4+1$)
- $n$ is the number of constraints (here $n=2$)

We define the witness:

$w=[1,x,y,v_{1},z]$

$L=$
| 1 | x | y | v1 | z |
|---+---+---+----+---|
| 0 | 1 | 0 |  0 | 0 |
| 0 | 0 | 0 |  1 | 0 |

$R=$
| 1 | x | y | v1 | z |
|---+---+---+----+---|
| 0 | 0 | 1 |  0 | 0 |
| 0 | 0 | 0 |  0 | 1 |

$O=$
|  1 | x | y | v1 | z |
|----+---+---+----+---|
|  0 | 0 | 0 |  1 | 0 |
| 10 | 0 | 0 |  0 | 0 |

#+BEGIN_SRC sage :session . :exports both
  import numpy as np

  x=2; y=5; vv1=10; z=1

  # witness vector
  w =  [ 1, x, y, vv1, z]

  # coefficient matrices
  L = [[0, 1,  0,  0,  0 ],
       [0, 0,  0,  1,  0 ]]

  R = [[0, 0,  1,  0,  0 ],
       [0, 0,  0,  0,  1 ]]

  O = [[0, 0,  0,  1,  0 ],
       [10, 0,  0,  0,  0 ]]

  result = np.matmul(O, w) == np.matmul(L, w) * np.matmul(R, w)

  assert result.all(), "R1CS constraints are not satisfied"
  print("R1CS constraints are satisfied")
#+END_SRC

#+RESULTS:
: R1CS constraints are satisfied

We now break the $O,L,R$ matrices into $m=5$ column vectors and interpolate them on $x=(0,1,\ldots, n-1)$  to produce $m$ polynomials each:

For the $L$:

| x   | u1(x) | u2(x) | u3(x) | u4(x) | u5(x) |
|-----+-------+-------+-------+-------+-------|
| *0* |     0 |     1 |     0 |     0 |     0 |
| *1* |     0 |     0 |     0 |     1 |     0 |

- $u_{1}(0) = 0$ and $u_{1}(1)=0$, therefore $u_{1}(x)=0$
- $u_{2}(0) = 1$ and $u_{2}(1)=0$, therefore $u_{2}(x)=1-x$
- $u_{3}(0) = 0$ and $u_{3}(1)=0$, therefore $u_{3}(x)=0$
- $u_{4}(0) = 0$ and $u_{4}(1)=1$, therefore $u_{4}(x)=x$
- $u_{5}(0) = 0$ and $u_{5}(1)=0$, therefore $u_{5}(x)=0$

#+BEGIN_SRC sage :session . :exports both
import numpy as np

FR = RationalField()
Rx.<x> = PolynomialRing(FR)

xs = [0,1]

ys = [0,0]
u1 = Rx.lagrange_polynomial(zip(xs,ys))
u1

ys = [1,0]
u2 = Rx.lagrange_polynomial(zip(xs,ys))
u2

ys = [0,0]
u3 = Rx.lagrange_polynomial(zip(xs,ys))
u3

ys = [0,1]
u4 = Rx.lagrange_polynomial(zip(xs,ys))
u4

ys = [0,0]
u5 = Rx.lagrange_polynomial(zip(xs,ys))
u5

# or

us = []
for col in np.matrix.transpose(np.array(L)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  us.append(p)

us
#+END_SRC

#+RESULTS:
: 0
: -x + 1
: 0
: x
: 0
: [0, -x + 1, 0, x, 0]

For the $R$:

| x   | v1(x) | v2(x) | v3(x) | v4(x) | v5(x) |
|-----+-------+-------+-------+-------+-------|
| *0* |     0 |     0 |     1 |     0 |     0 |
| *1* |     0 |     0 |     0 |     0 |     1 |

- $v_{1}(0) = 0$ and $v_{1}(1)=0$, therefore $v_{1}(x)=0$
- $v_{2}(0) = 0$ and $v_{2}(1)=0$, therefore $v_{2}(x)=0$
- $v_{3}(0) = 1$ and $v_{3}(1)=0$, therefore $v_{3}(x)=1-x$
- $v_{4}(0) = 0$ and $v_{4}(1)=0$, therefore $v_{4}(x)=0$
- $v_{5}(0) = 0$ and $v_{5}(1)=1$, therefore $v_{5}(x)=x$

#+BEGIN_SRC sage :session . :exports both
import numpy as np

FR = RationalField()
Rx.<x> = PolynomialRing(FR)

xs = [0,1]

vs = []
for col in np.matrix.transpose(np.array(R)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  vs.append(p)

vs
#+END_SRC

#+RESULTS:
: [0, 0, -x + 1, 0, x]

For the $O$:

| x   | w1(x) | w2(x) | w3(x) | w4(x) | w5(x) |
|-----+-------+-------+-------+-------+-------|
| *0* |     0 |     0 |     0 |     1 |     0 |
| *1* |    10 |     0 |     0 |     0 |     0 |

- $w_{1}(0) = 0$ and $w_{1}(1)=10$, therefore $w_{1}(x)=10x$
- $w_{2}(0) = 0$ and $w_{2}(1)=0$, therefore $w_{2}(x)=0$
- $w_{3}(0) = 0$ and $w_{3}(1)=0$, therefore $w_{3}(x)=0$
- $w_{4}(0) = 1$ and $w_{4}(1)=0$, therefore $w_{4}(x)=1-x$
- $w_{5}(0) = 0$ and $w_{5}(1)=0$, therefore $w_{5}(x)=0$

#+BEGIN_SRC sage :session . :exports both
import numpy as np

FR = RationalField()
Rx.<x> = PolynomialRing(FR)

xs = [0,1]

ws = []
for col in np.matrix.transpose(np.array(O)):
  p = Rx.lagrange_polynomial(zip(xs,col))
  ws.append(p)

ws
#+END_SRC

#+RESULTS:
: [10*x, 0, 0, -x + 1, 0]

Check whether $l(x) \cdot r(x) == o(x)$:

#+BEGIN_SRC sage :session . :exports both
w

l = np.dot(us, w)
r = np.dot(vs, w)
o = np.dot(ws, w)

l(0) * r(0) == o(0)
l(1) * r(1) == o(1)
#+END_SRC

#+RESULTS:
: [1, 2, 5, 10, 1]
: True
: True

QAP:

$\forall x: \quad l(x) \cdot r(x) = o(x) + h(x)\cdot T(x)$

We construct $T(x)$. Since there are 2 rows, and we interpolate in $x=0$ and $x=1$:

$T(x)=(x-0) \cdot (x-1)$

The prover needs to calculate $h(x)$:

$h(x)=\frac{l(x)*r(x)-o(x)}{T(x)}$

#+BEGIN_SRC sage :session . :exports both
T=x*(x-1)
T

h=(l*r-o)/T
h
#+END_SRC

#+RESULTS:
: x^2 - x
: -32

Now the prover has $l(x),r(x),o(x)$ and $h(x)$.
Verifier samples random $\tau$ and via [[id:e52ff81b-e1a8-4153-b8e7-710ab93f82d9][Schwartz-Zippel Lemma]] is convinced that the QAP holds:

#+BEGIN_SRC sage :session . :exports both
import random

tau = random.randint(-1000,1000)

l(tau) * r(tau) == o(tau) + T(tau)*h(tau)
#+END_SRC

#+RESULTS:
: True


