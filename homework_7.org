* IN-PROGRESS Practice Problems
- https://rareskills.io/post/arithmetic-circuit#:~:text=in%20that%20book.-,Practice%20Problems,-Create%20an%20arithmetic
** DONE Create an arithmetic circuit that takes signals $x_1,x_2\ldots,x_n$ and is satisfied if at least one signal is 0.

$x_1  \cdot x_2 \cdot \ldots \cdot x_n \equiv 0$
$\forall i\leq n \quad x_{i} \cdot (1-x_i) \equiv 0$

** DONE Create an arithmetic circuit that takes signals $x_1,x_2\ldots,x_n$ and is satsified if all signals are 1.

$x_1  \cdot x_2 \cdot \ldots \cdot x_n \equiv 1$
$\forall i\leq n \quad x_{i} \cdot (1-x_i) \equiv 0$

** DONE A bipartite graph is a graph that can be colored with two colors such that no two neighboring nodes share the same color. Devise an arithmetic circuit scheme to show you have a valid witness of a 2-coloring of a graph.

Let $n$ be the number of nodes, let's assign blue = 1, red = 2.

Every node $x_1,x_2,\ldots x_n$ can be either red or blue:

$\forall i \leq n : \quad (x_i-1) \cdot (x_i-2) \equiv 0$

No two neighbouring nodes can have the same colour:

| node_i | node_j | product |
|      1 |      1 |       1 |
|      2 |      1 |       2 |
|      1 |      2 |       2 |
|      2 |      2 |       4 |

From the table above we can see that the only acceptable product of two neighbouring nodes is 2:

$\forall i,j \leq n, i \neq j: \quad  (x_i\cdot x_j -2) \equiv 0$

Alternatively we can model this constraint as:

$\forall i,j \leq n, i \neq j: \quad  (x_i - x_j)^2 \neq 0$
** DONE Create an arithmetic circuit that constrains k to be the maximum of x, y, or z. That is, k should be equal to x if x is the maximum value, and same for y and z.

$k=\text{max}(x,y,x) \Leftrightarrow k \geq x \land k \geq y \land k \geq z$

We need to repeat the same set of constraint for each number $x,y,z$.
Let's assume n=4.

1) Binary decomposition of k,x,y and z (Big Endian) must fit in $n-1=3$ bits.
   An example for k:

  |           | MSB |     | LSB |
  | index     | 0   |   1 | 2   |
  | bit value | k_2 | k_1 | k_0 |

  Repeated for all the values:

   $2^2 \cdot k_2 + 2^1 \cdot k_1 + 2^0 \cdot k_0 \equiv k$
   $2^2 \cdot x_2 + 2^1 \cdot x_1 + 2^0 \cdot x_0 \equiv x$
   $2^2 \cdot y_2 + 2^1 \cdot y_1 + 2^0 \cdot y_0 \equiv y$
   $2^2 \cdot z_2 + 2^1 \cdot z_1 + 2^0 \cdot z_0 \equiv z$

2) binary decomposition constraints:
  $k_2\cdot(1-k_2) \equiv 0$
  $k_1\cdot(1-k_1) \equiv 0$
  $k_0\cdot(1-k_0) \equiv 0$

  $x_2\cdot(1-x_2) \equiv 0$
  $x_1\cdot(1-x_1) \equiv 0$
  $x_0\cdot(1-x_0) \equiv 0$

  $y_2\cdot(1-y_2) \equiv 0$
  $y_1\cdot(1-y_1) \equiv 0$
  $y_0\cdot(1-y_0) \equiv 0$

  $z_2\cdot(1-z_2) \equiv 0$
  $z_1\cdot(1-z_1) \equiv 0$
  $z_0\cdot(1-z_0) \equiv 0$

3) $2^{n-1} + (k-x)$ n=4 bit binary decomposition constraint:

   $2^3+k-x \equiv 2^3 \cdot a_{3} + 2^2 \cdot a_{2} + 2^1 \cdot a_{1} + 2^0 a_{0}$

4) $2^{n-1} + (k-y)$ n=4-bit binary decomposition constraint:

   $2^3+k-y \equiv 2^3 \cdot b_{3} + 2^2 \cdot b_{2} + 2^1 \cdot b_{1} + 2^0 b_{0}$

5) $2^{n-1} + (k-z)$ n=4-bit binary decomposition constraint:

   $2^3+k-z \equiv 2^3 \cdot c_{3} + 2^2 \cdot c_{2} + 2^1 \cdot c_{1} + 2^0 c_{0}$

6) MSB of the n=4 bit decompositions are 1:
  $a_3 \equiv 1$
  $b_3 \equiv 1$
  $c_3 \equiv 1$

7) We also need to make sure that one of the numbers equals k (or else k could be greater than all three):
  $(k-x) \cdot (k-y) \cdot (k-z) == 0$
*** DONE Create an arithmetic circuit that takes signals $x_1,x_2\ldots,x_n$, constrains them to be binary, and outputs 1 if at least one of the signals is 1.
/Hint: this is tricker than it looks. Consider combining what you learned in the first two problems and using the NOT gate./

The problem can be reformulated as "an arithmetic circuit that is satisfied if not all signals are 0".

"All signals are 0" can be expressed with the following circuit:

$(1-x_1) \cdot \ldots \cdot (1-x_n) \equiv 1$

Negating it we get:

$1-((1-x_1) \cdot \ldots \cdot (1-x_n)) \equiv 1$

We also need to constrain all $x_i$ to be binary:


$\forall i\leq n \quad x_{i} \cdot (1-x_i) \equiv 0$

#+BEGIN_SRC sage :session . :exports both
#from sympy import symbols
x1 = var('x1')
x2 = var('x2')
x3 = var('x3')
x4 = var('x4')

c1 = 1-((1-x1) * (1-x2) * (1-x3) * (1-x4)) == 1

c1.subs({x1: 0, x2: 0, x3: 0, x4:1})
c1.subs({x1: 1, x2: 1, x3: 1, x4:1})
c1.subs({x1: 0, x2: 0, x3: 0, x4:0})
#+END_SRC

#+RESULTS:
: 1 == 1
: 1 == 1
: 0 == 1
*** DONE Create an arithmetic circuit to determine if a signal v is a power of two (1, 2, 4, 8, etc).
/Hint: create an arithmetic circuit that constrains another set of signals to encode the binary representation of v, then place additional restrictions on those signals./

Assuming v is a n-bit number it's binary decomposition is expressed as:

$2^{n-1} \cdot a_{n-1} + \ldots +2^0 \cdot a_0 \equiv v$
$\forall i\leq n-1 \quad a_{i} \cdot (1-a_i) \equiv 0$

In order for v to be a power of 2 it's MSB must be 1 with all the other bits set to 0:

$a_{n-1} \equiv 1$
$a_{n-2} \equiv 0$
$\ldost$
$a_{0} \equiv 0$

#+BEGIN_SRC sage :session . :exports both
a3 = var('a3')
a2 = var('a2')
a1 = var('a1')
a0 = var('a0')

c1 = 2^3*a3+2^2*a2+2^1*a1+1*a0
c2 = a3 == 1
c3 = a2 == 0
c4 = a1 == 0
c5 = a0 == 0

v=2^3-1
bin(v)

c1.subs({a3: 1, a2: 0, a1: 0, a0: 0}) == v
c2.subs({a3: 1})
c3.subs({a2: 0})
c4.subs({a1: 0})
c5.subs({a0: 0})

v=2^3+1
bin(v)

c1.subs({a3: 1, a2: 0, a1: 0, a0: 1}) == v
c2.subs({a3: 1})
c3.subs({a2: 0})
c4.subs({a1: 0})
c5.subs({a0: 1})
#+END_SRC

#+RESULTS:
#+begin_example
'0b111'
8 == 7
1 == 1
0 == 0
0 == 0
0 == 0
'0b1001'
9 == 9
1 == 1
0 == 0
0 == 0
1 == 0
#+end_example

*** DONE Create an arithmetic circuit that models the [[https://en.wikipedia.org/wiki/Subset_sum_problem][Subset Sum]] problem. Given a set of integers (assume they are all non-negative), determine if there is a subset that sums to a given value. For example, given the set $\{3,5,17,21\}$ and $k=22$, there is a subset $\{5,17\}$ that sums to 22. Of course, a subset sum problem does not necessarily have a solution.

/Hint: Use a "switch" that is 0 or 1 if a number is part of the subset or not./

Let $S=\{s_1,\ldots, s_n\}$ be the set of integers $\geq 0$.

We introduce selector variables $z_i \in \{0,1\}$ s.t:

z_1 \cdot s_1 + \ldost z_n\cdot s_n \equiv k$

A witness is then a vector of selectors: $[z_{1}, \ldots, z_{n}]$

#+BEGIN_SRC sage :session . :exports both
k=22

z1=var('z1')
z2=var('z2')
z3=var('z3')
z4=var('z4')

c1 = 3*z1 +5*z2 + 17*z3 + 21*z4 == k
c2=z1*(1-z1)==0
c3=z2*(1-z2)==0
c4=z3*(1-z3)==0
c5=z4*(1-z4)==0

c1.subs({z1 : 0, z2 : 1, z3 : 1, z4:0})
c2.subs({z1 : 0, z2 : 1, z3 : 1, z4:0})
c3.subs({z1 : 0, z2 : 1, z3 : 1, z4:0})
c4.subs({z1 : 0, z2 : 1, z3 : 1, z4:0})
c5.subs({z1 : 0, z2 : 1, z3 : 1, z4:0})
#+END_SRC

#+RESULTS:
: 22 == 22
: 0 == 0
: 0 == 0
: 0 == 0
: 0 == 0
*** TODO 
