* IN-PROGRESS R1CS
- https://www.notion.so/Homework-7-R1CS-2fd956fcccf742398435ab9b2da8f934
** DONE Problem 1
Create a graph with 2 nodes and 1 edge and write constraints for a 3-coloring.
Turn the 3-coloring to a rank 1 constraint system. If you forgot how to do this, consult the chapter on arithmetic circuits.

#+BEGIN_SRC dot :file problem_1_graph.png :exports results
graph G {
    x1 -- x2;
}
#+END_SRC

#+RESULTS:
[[file:problem_1_graph.png]]

We can adapt the [[file:homework_7.org][2 coloring]] and [[https://rareskills.io/post/arithmetic-circuit#:~:text=Example%201%3A%20Modeling%203%2Dcoloring%20with%20an%20Arithmetic%20Circuit][3 coloring]] to our problem.
Labeling the colors as before we have
- BLUE = 1
- RED = 2
- GREEN = 3

We constrain each node to have exactly one color, this gives us these constraints:

- Node $x_1$ is either BLUE, RED or GREEN:
  $(x_{1}-1) \cdot (x_{1}-2) \cdot (x_{1}-6) \equiv 0$

- Node $x_2$ is either BLUE, RED or GREEN:
  $(x_{2}-1) \cdot (x_{2}-2) \cdot (x_{2}-6) \equiv 0$

No two nodes can share the same color. Similar to before this can be modeled by contraining the product of two neighbouring nodes to take on a certain acceptable values:

| x1 | x2 | product |
|----+----+---------|
|  1 |  1 | 1       |
|  1 |  2 | *2*     |
|  1 |  3 | *3*     |
|  2 |  1 | *2*     |
|  2 |  2 | 4       |
|  2 |  3 | *6*     |
|  3 |  1 | *3*     |
|  3 |  2 | *6*     |
|  3 |  3 | 9       |

From this we have:

$(x_1 \cdot x_2 -2) \cdot (x_1 \cdot x_2 -3) \cdot (x_1 \cdot x_2 -6)$

We can now turn these into an R1CS.
For the first two color constraints we have:

#+BEGIN_SRC maxima :exports both :results output replace
print(expand ((x1-1)*(x1-2)*(x1-6)));
print(expand ((x2-1)*(x2-2)*(x2-6)));
#+END_SRC

#+RESULTS:
:   3       2
: x1  - 9 x1  + 20 x1 - 12
:   3       2
: x2  - 9 x2  + 20 x2 - 12

And for the neigbouring constraint we have:

#+BEGIN_SRC maxima :exports both :results output replace
print(expand ((x1*x2-2)*(x1*x2-3)*(x1*x2-6)));
#+END_SRC

#+RESULTS:
:   3   3        2   2
: x1  x2  - 11 x1  x2  + 36 x1 x2 - 36

We can write these as:

$\begin{cases}
x_{1} \cdot x_{1}=v_{1} \\
x_{2} \cdot x_{2}=v_{2} \\
x_{1} \cdot x_{2}=v_{3} \\
v_{3} \cdot v_{3}=v_{4} \\
x_{1} \cdot v_{1} = 9v_{1} -20x_{1} +12 \\
x_{2} \cdot v_{2} = 9v_{2} -20x_{2} +12 \\
v_{3} \cdot v_{4} = 11v_{4} -36v_{3} + 36
\end{cases}$

** DONE Problem 2
Write python code that takes an R1CS matrix L, R, and O and a witness vector w and verifies.

$L\mathbf{w} \odot R\mathbf{w}=O\mathbf{w}$

Where $\odot$ is the hadamard (element-wise) product.

Use this to code to check your answer above is correct.

Let's assume:
$x_{1}=1$ (BLUE) and $x_{2}=2$ (RED) - but any two colors would work as long as they are different.

#+BEGIN_SRC sage :session . :exports both
  import numpy as np

  x1=1;x2=2;
  v1=x1*x1;v2=x2*x2;v3=x1*x2;v4=v3*v3

  # witness vector
  w =  np.array([ 1, x1, x2, v1, v2, v3, v4])

  # coefficient matrices
  L = np.matrix([[0, 1,  0,  0,  0,  0,  0 ],
                 [0, 0,  1,  0,  0,  0,  0 ],
                 [0, 1,  0,  0,  0,  0,  0 ],
                 [0, 0,  0,  0,  0,  1,  0 ],
                 [0, 1,  0,  0,  0,  0,  0 ],
                 [0, 0,  1,  0,  0,  0,  0 ],
                 [0, 0,  0,  0,  0,  1,  0 ]])

  R = np.matrix([[0, 1,  0,  0,  0,  0,  0 ],
                 [0, 0,  1,  0,  0,  0,  0 ],
                 [0, 0,  1,  0,  0,  0,  0 ],
                 [0, 0,  0,  0,  0,  1,  0 ],
                 [0, 0,  0,  1,  0,  0,  0 ],
                 [0, 0,  0,  0,  1,  0,  0 ],
                 [0, 0,  0,  0,  0,  0,  1 ]])

  O = np.matrix([[0, 0,  0,  1,  0,  0,  0 ],
                 [0, 0,  0,  0,  1,  0,  0 ],
                 [0, 0,  0,  0,  0,  1,  0 ],
                 [0, 0,  0,  0,  0,  0,  1 ],
                 [12, -20,  0,  9,  0,  0,  0 ],
                 [12, 0,  -20,  0,  9,  0,  0 ],
                 [36,  0,  0,  0,  0,  -36,  11 ]])

  result = np.matmul(O, w) == np.multiply(np.matmul(L, w) , np.matmul(R, w))

  assert result.all(), "R1CS constraints are not satisfied"
  print("R1CS constraints are satisfied")
#+END_SRC

#+RESULTS:
: matrix([[ True,  True,  True,  True,  True,  True,  True]])
: R1CS constraints are satisfied

** IN-PROGRESS Problem 3
Given an R1CS of the form:

$L \vec{\left[s\right]_{1}} \odot R \vec{\left[s\right]_{2}} = O \vec{\left[s\right]_{1}} \odot \vec{\left[G_{2}\right]_{2}}$

where:
- $L$, $R$, and $O$ are $n \times m$ matrices of field elements
- $s$ is a vector of $G_1$ or $G_2$ points

Write python code that verifies the formula.

*Hint 1*: Each row of the matrices is a separate pairing.
*Hint 2*: When you get $s$ encrypted with both $G_{1}$ and $G_{2}$ generators, you don't know whether or not they have the same discrete logarithm.
However, it is straightforward to check using another equation.
Figure out how to discover if $sG_{1} == sG_{2}$ if you are given the elliptic curve points but not $s$.

#+BEGIN_SRC sage :session . :exports both
  #import numpy as np
  import py_ecc.bn128 as bn128
  from py_ecc.fields import (
  bn128_FQ as FQ,
  bn128_FQ2 as FQ2,
  bn128_FQ12 as FQ12
  )

  p=21888242871839275222246405745257275088696311157297823662689037894645226208583
  Fp=GF(p)
  E = EllipticCurve(Fp, [0,3])
  G1 = E(1,2)
  k = 2
  Rx.<x>=Fp[]
  Fp2 = GF(p^k, name='i', modulus=x^k + 1)

  # https://eips.ethereum.org/EIPS/eip-197#:~:text=q%20%3D%2021888242871839275222246405745257275088548364400416034343698204186575808495617.-,Definition%20of%20the%20groups,-The%20groups%20G_1
  a=0
  TwistB=3*Fp2([9,1])^(-1) # 3/(i+9)
  E2 = EllipticCurve(Fp2, [a,TwistB])

  # [a,b] -> a + i*b
  x_G2 = Fp2([
  10857046999023057135944570762232829481370756359578518086990519993285655852781,
  11559732032986387107991004021392285783925812861821192530917403151452391805634
  ])

  y_G2 = Fp2([
  8495653923123431417604973247489272438418190587263600148770280649306958101930,
  4082367875863433681332203403145435568316851327593401208105741076214120093531
  ])

  G2 = E2(x_G2, y_G2)

  # computes e(Q \in G2, P \in G1)
  # returns an element in FQ12 (extension tower Fp^2 -> Fp^6 -> Fp12)
  def pairing(P,Q):
      ePQ = bn128.pairing((bn128.FQ2([int(Q[0][0]), int(Q[0][1])]),
                           bn128.FQ2([int(Q[1][0]), int(Q[1][1])])),
                          (bn128.FQ(int(P[0])), bn128.FQ(int(P[1]))));
      return ePQ

  # computes M*v, where M is a nxm matrix, v is a vector of length m
  def matrix_dot_vector(matrix, vector):
      rows_A = len(matrix)
      cols_A = len(matrix[0])

      if len(vector) != cols_A:
          raise ValueError(f"Incompatible dimensions: matrix has {cols_A} columns but vector has {len(vector)} elements.")

      result = [0 for _ in range(rows_A)]

      for i in range(rows_A):
          result[i] = sum(matrix[i][j] * vector[j] for j in range(cols_A))

      return result

  x1=1;x2=2;
  v1=x1*x1;v2=x2*x2;v3=x1*x2;v4=v3*v3;

  # witness vector
  w =  [ Fp(1), Fp(x1), Fp(x2), Fp(v1), Fp(v2), Fp(v3), Fp(v4)]

  # coefficient matrices
  L = [[Fp(0), Fp(1),  Fp(0),  Fp(0),  Fp(0),  Fp(0),  Fp(0) ],
       [Fp(0), Fp(0),  Fp(1),  Fp(0),  Fp(0),  Fp(0),  Fp(0) ],
       [Fp(0), Fp(1),  Fp(0),  Fp(0),  Fp(0),  Fp(0),  Fp(0) ],
       [Fp(0), Fp(0),  Fp(0),  Fp(0),  Fp(0),  Fp(1),  Fp(0) ],
       [Fp(0), Fp(1),  Fp(0),  Fp(0),  Fp(0),  Fp(0),  Fp(0) ],
       [Fp(0), Fp(0),  Fp(1),  Fp(0),  Fp(0),  Fp(0),  Fp(0) ],
       [Fp(0), Fp(0),  Fp(0),  Fp(0),  Fp(0),  Fp(1),  Fp(0) ]]

  R = [[Fp(0), Fp(1),  Fp(0),  Fp(0),  Fp(0),  Fp(0),  Fp(0) ],
       [Fp(0), Fp(0),  Fp(1),  Fp(0),  Fp(0),  Fp(0),  Fp(0) ],
       [Fp(0), Fp(0),  Fp(1),  Fp(0),  Fp(0),  Fp(0),  Fp(0) ],
       [Fp(0), Fp(0),  Fp(0),  Fp(0),  Fp(0),  Fp(1),  Fp(0) ],
       [Fp(0), Fp(0),  Fp(0),  Fp(1),  Fp(0),  Fp(0),  Fp(0) ],
       [Fp(0), Fp(0),  Fp(0),  Fp(0),  Fp(1),  Fp(0),  Fp(0) ],
       [Fp(0), Fp(0),  Fp(0),  Fp(0),  Fp(0),  Fp(0),  Fp(1) ]]

  O = [[Fp(0), Fp(0), Fp(0),   Fp(1),   Fp(0), Fp(0),  Fp(0)],
       [Fp(0), Fp(0), Fp(0),   Fp(0),   Fp(1), Fp(0),  Fp(0)],
       [Fp(0), Fp(0), Fp(0),   Fp(0),   Fp(0), Fp(1),  Fp(0)],
       [Fp(0), Fp(0), Fp(0),   Fp(0),   Fp(0), Fp(0),  Fp(1)],
       [Fp(12), Fp(-20), Fp(0),   Fp(9),   Fp(0), Fp(0),  Fp(0)],
       [Fp(12), Fp(0), Fp(-20),   Fp(0),   Fp(9), Fp(0),  Fp(0)],
       [Fp(36), Fp(0), Fp(0),   Fp(0),   Fp(0), Fp(-36), Fp(11)]]

  # s1 = w * G1
  s1=[G1*v for v in w]
  # s2 = w * G2
  s2=[G2*v for v in w]

  # L * s1
  L_times_s1 = matrix_dot_vector(L, s1)
  # R * s2
  R_times_s2 = matrix_dot_vector(R, s2)

  # O * s1
  O_times_s1 = matrix_dot_vector(O, s1)
  # G2 vector
  G2_vec = [G2 for _ in range(len(w))]

  #pairing(L_times_s1[0],R_times_s2[0]) == pairing(O_times_s1[0],G2_vec[0])
  #pairing(L_times_s1[1],R_times_s2[1]) == pairing(O_times_s1[1],G2_vec[1])
  #pairing(L_times_s1[2],R_times_s2[2]) == pairing(O_times_s1[2],G2_vec[2])
  #pairing(L_times_s1[3],R_times_s2[3]) == pairing(O_times_s1[3],G2_vec[3])
  pairing(L_times_s1[4],R_times_s2[4]) == pairing(O_times_s1[4],G2_vec[4])
  #pairing(L_times_s1[5],R_times_s2[5]) == pairing(O_times_s1[5],G2_vec[5])
  #pairing(L_times_s1[6],R_times_s2[6]) == pairing(O_times_s1[6],G2_vec[6])

  #result = [pairing(L_times_s1[i],R_times_s2[i]) == pairing(O_times_s1[i],G2_vec[i]) for i in range(len(w))]



#+END_SRC

#+RESULTS:
: False
