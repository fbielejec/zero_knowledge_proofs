#+STARTUP: overview
#+latex_class_options: [12pt]

* Contents
:PROPERTIES:
:VISIBILITY:  all
:TOC:      :include all :ignore this
:END:
:CONTENTS:
- [[#problem-set][Problem set]]
- [[#problem-1][Problem 1:]]
- [[#problem-2][Problem 2]]
- [[#problem-3][Problem 3]]
- [[#problem-4][Problem 4]]
- [[#problem-5][Problem 5]]
- [[#problem-6][Problem 6]]
- [[#problem-7][Problem 7]]
- [[#problem-8][Problem 8]]
  - [[#manual-implementation][Manual implementation]]
:END:

* Problem set
- https://almondine-song-c43.notion.site/Homework-1-26cad185ffbc479faf060b5867b442ec

For all problems below, assume the finite field is p = 71.

The following Python code will be useful:

#+BEGIN_SRC jupyter-python :session zk :kernel zero_knowledge :async yes :exports both
-5 % p # number congruent to -5
pow(5, -1, p) # multiplicative inverse of 5
#+END_SRC

* DONE Problem 1:

Find the elements in a finite field that are congruent to the following values:

- $-1$
- $-4$
- $-160$
- $500$

---

*NOTES*

- congruent = compatible, similar

=Definition: congruence=

Two integers $a,b \in \mathbb{Z}$ are *congruent* modulo some $p \geq 1$ if there is an integer $k \in \mathbb{Z}$ such that:

$a=k \cdot p + b$

We then write the *congruence relation* as:

$a \equiv b \quad \text{ mod } m$

where:
- $m$ is called the *modulus*

Congruence relation is compatible with the operations of addition, subtraction, and multiplication

---

#+BEGIN_SRC jupyter-python :session zk :kernel zero_knowledge :async yes :exports both
p = 71
congruent = {}

for field_element in range(0,p+1):
  for z in [-1,-4,-160,500]:
    if z % p == field_element: congruent.setdefault(field_element, []).append(z)

print(f"{congruent}");
#+END_SRC

#+RESULTS:
: {3: [500], 53: [-160], 67: [-4], 70: [-1]}

* DONE Problem 2
Find the elements that are congruent to a = 5/6, b = 11/12, and c = 21/12
Verify your answer by checking that a + b = c (in the finite field)

#+BEGIN_SRC jupyter-python :session zk :kernel zero_knowledge :async yes :exports both
p = 71

def field_div(a, b, p):
  '''a * b^{-1} mod p'''
  return (a * pow(b, -1, p)) % p

a=field_div(5,6,p)
b=field_div(11,12,p)
c=field_div(21,12,p)

(a+b) % p == c
#+END_SRC

#+RESULTS:
: True

* DONE Problem 3
Find the elements that are congruent to a = 2/3, b = 1/2, and c = 1/3.

Verify your answer by checking that a * b = c (in the finite field)

#+BEGIN_SRC jupyter-python :session zk :kernel zero_knowledge :async yes :exports both
p = 71

def field_div(a, b, p):
  '''a * b^{-1} mod p'''
  return (a * pow(b, -1, p)) % p

a=field_div(2,3,p)
b=field_div(1,2,p)
c=field_div(1,3,p)

(a*b) % p == c
#+END_SRC

#+RESULTS:
: True

* DONE Problem 4
The inverse of a 2 x 2 matrix $A$ is:

$A^{-1}=\frac{1}{\text{det}}\begin{bmatrix}d & -b\\-c & a\end{bmatrix}$

where $A$ is:

$A = \begin{bmatrix}a & b\\c & d\end{bmatrix}$

And the determinant det is:

$\text{det}=a \times d-b\times c$

Compute the inverse of the following matrix in the finite field:

$\begin{bmatrix}1 & 1\\1 & 4\end{bmatrix}$

Verify your answer by checking that:

$AA^{-1}=I$

Where $I$ is the identity matrix.

#+BEGIN_SRC jupyter-python :session zk :kernel zero_knowledge :async yes :exports both
import numpy as np

p = 71

a = [[1,1],
     [1,4]]

# 2x2 identity matrix
e = [[1,0],
     [0,1]]

def additive_inv(a,p):
  return p - a % p

def det(a):
  return a[0][0] * a[1][1] - a[0][1] * a[1][0]

def m_inv(a,p):
  det_inv = pow(det(a),-1,p) # det(a)^{-1}
  return [[(a[1][1] * det_inv) % p, additive_inv(a[0][1] * det_inv, p)],
          [additive_inv(a[1][0] * det_inv,p), (a[0][0] * det_inv) % p]]

print(f"{a}^-1 = {m_inv(a,p)} (in GF({p})")
print("a x a^-1 == e:",(np.matmul(a, m_inv(a,p)) % p == e).all())
#+END_SRC

#+RESULTS:
: [[1, 1], [1, 4]]^-1 = [[25, 47], [47, 24]] (in GF(71)
: a x a^-1 == e: True
* DONE Problem 5
What is the modular square root of 12?

Verify your answer by checking that x * x = 12 (mod 71)

Use brute force to find the answer (in Python)

#+BEGIN_SRC jupyter-python :session zk :kernel zero_knowledge :async yes :exports both
p = 71
y = 12

# we need x: x * x = y (mod p)
square_root = [x for x in range(p) if (x * x) % p == y] # range can be [1,p+1] or [0,p], boils down to the same modulo arithmetic
print(f"Square root of {y} (mod {p}): {square_root}")

assert((square_root[0] * square_root[0]) % p == 12)
assert(-square_root[0] % p == square_root[1]) # multiplicative inverse
#+END_SRC

#+RESULTS:
: Square root of 12 (mod 71): [15, 56]

* IN-PROGRESS Problem 6
Suppose we have the following polynomials:

$p(x)=52x^2+24x+61$
$q(x)=40x^2+40x+58$

Use the galois library in Python to find the roots of p(x) and q(x).

#+BEGIN_SRC jupyter-python :session zk :kernel zero_knowledge :async yes :exports both
import galois

#+END_SRC

* TODO Problem 7
* IN-PROGRESS Problem 8
What is Lagrange interpolation and what does it do?

Find a polynomial that crosses through the points $(0, 1), (1, 2), (2, 1).$

Use this Stackoverflow answer as a starting point: https://stackoverflow.com/a/73434775

---

*NOTES*

*Lagrange interpolation* is a method of finding the unique polynomial $P(x)$ of degree $\leq n$ that passes through $n+1$ points $(x_0, y_0), (x_1, y_1), \dots, (x_n, y_n)$.

It constructs $P(x)$ as a weighted sum of the so called /basis polynomials/ $L_i(x)$:


$P(x) = \sum_{i=0}^n y_i \cdot L_i(x), \quad \text{where} \quad L_i(x) = \prod_{\substack{0 \leq j \leq n \\ j \neq i}} \frac{x - x_j}{x_i - x_j}$
---

#+BEGIN_SRC jupyter-python :session zk :kernel zero_knowledge :async yes :exports both
import galois

p = 71
GF = galois.GF(71)
print(f"{GF}");

x = GF([0,1,2])
y = GF([1,2,1])

f = galois.lagrange_poly(x, y);

print(f"Unique polynomial passing through ({x[0]},{y[0]}), ({x[1]},{y[1]}), ({x[2]},{y[2]}): P(x)={f} in GF({p})");
#+END_SRC

#+RESULTS:
: <class 'galois.GF(71, primitive_element='7', irreducible_poly='x + 64')'>
: Unique polynomial passing through (0,1), (1,2), (2,1): P(x)=70x^2 + 2x + 1 in GF(71)

** IN-PROGRESS Manual implementation

#+BEGIN_SRC sage  :session . :exports both
p = 71
F=GF(p)
R = PolynomialRing(F,'x')
x = R.gen()

points = [(0, 1), (1, 2), (2, 1)]

def lagrange_basis(i, points):
    xi, yi = points[i]
    product = 1
    for j in range(len(points)):
        if j != i:
            xj = points[j][0]
            product *= (x - xj) / (xi - xj)
    return product

P = sum(yi * lagrange_basis(i, points) for i, (xi, yi) in enumerate(points))
P
#+END_SRC

#+RESULTS:
: 70*x^2 + 2*x + 1
